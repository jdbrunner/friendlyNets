%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{FriendlyNets}
\date{Jun 29, 2023}
\release{0.2}
\author{James D.\@{} Brunner and Nicholas Chia}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxAtStartPar
FriendlyNets provides a method for assessing the promotion/inhibition effect on a microbe of a microbial community using a network of community interactions. At its core, FriendlyNets judges how much a network
promotes or inhibits one of its nodes. It does this by assuming a set dynamical system represented by the network, and using the resulting dynamics. FriendlyNets is also packaged with functions for generating
a network from a set of genome\sphinxhyphen{}scale metabolic by simulating pairwise growth using the methods from {[}\hyperlink{cite.index:id3}{KSC22}{]}.

\sphinxAtStartPar
Check out the {\hyperref[\detokenize{usage::doc}]{\sphinxcrossref{\DUrole{doc}{Usage}}}} section for further information, including how to
{\hyperref[\detokenize{usage:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{install}}}} the project.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
This project is under active development.
\end{sphinxadmonition}

\sphinxstepscope


\chapter{Usage}
\label{\detokenize{usage:usage}}\label{\detokenize{usage::doc}}

\section{Installation}
\label{\detokenize{usage:installation}}\label{\detokenize{usage:id1}}
\sphinxAtStartPar
To use FriendlyNets, clone from github:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }clone\PYG{+w}{ }https://github.com/jdbrunner/friendlyNets.git
\end{sphinxVerbatim}

\sphinxAtStartPar
(We plan to add pip installation in the future)

\sphinxAtStartPar
You will also need to add the directory to your python path, for example using

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{expanduser}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZti{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}\PYG{n}{location}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{friendlyNets}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{location}} is the path to the folder that you cloned friendlyNets into.

\sphinxAtStartPar
\sphinxstylestrong{Dependencies}

\sphinxAtStartPar
We use \sphinxhref{https://joblib.readthedocs.io/en/latest/}{joblib} for parallel computing.

\sphinxAtStartPar
Our implementation of SteadyComX uses \sphinxhref{https://www.gurobi.com/documentation/9.5/}{Gurobi} and gurobiâ€™s python package for joint FBA, and expects \sphinxhref{https://opencobra.github.io/cobrapy/}{cobrapy} models as input.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Unfortunately, we do not currently have access to a CPLEX license in order to implement CPLEX as a solver option.
\end{sphinxadmonition}


\section{Using the Method for a Set of Samples}
\label{\detokenize{usage:using-the-method-for-a-set-of-samples}}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
What follows is a plan of action. At this point, the data formatting and network building steps are incomplete.
\end{sphinxadmonition}

\sphinxAtStartPar
FriendlyNets is designed to predict the invasion of a single species into a community. It is designed around microbiome studies, but written more generally so that nodes can be anything as long as interaction parameters between
the nodes are known. For microbiome studies, we provide a method to generate the set of interaction parameters from a set of genome\sphinxhyphen{}scale metabolic models which must be provided by the user.

\sphinxAtStartPar
We assume that the user has a table in .csv format with rows indexed by species of interest and columns indexed by sample name that contains abundance data for each species in each sample (relative or absolute). Additionally, if an assessment of the predictive power of the method is desired (which may indicate
the extent to which experimental outcome depends network effects), a metadata file must be provided as .csv with rows indexed by sample name and a column indicating experimental outcome of an invasion experiment


\subsection{Creating the full network}
\label{\detokenize{usage:creating-the-full-network}}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Optional: A network can instead be loaded as pandas DataFrame with nodes and columns being names of the species in the data, formatted  as \sphinxcode{\sphinxupquote{Network.loc{[}m\_1,m\_2{]}}} contains the interaction with source \sphinxcode{\sphinxupquote{m\_1}} and target \sphinxcode{\sphinxupquote{m\_2}}.
\end{sphinxadmonition}

\sphinxAtStartPar
For microbiome data paired with a set of genome\sphinxhyphen{}scale metabolic models, the method creates network of interactions for all co\sphinxhyphen{}occurring taxa that have an associated user\sphinxhyphen{}provided genome\sphinxhyphen{}scale model.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{make\PYGZus{}gem\PYGZus{}network} \PYG{k+kn}{import} \PYG{n}{make\PYGZus{}gem\PYGZus{}network}

\PYG{n}{full\PYGZus{}interaction\PYGZus{}network} \PYG{o}{=} \PYG{n}{make\PYGZus{}gem\PYGZus{}network}\PYG{p}{(}\PYG{n}{path\PYGZus{}to\PYGZus{}gsm\PYGZus{}info}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This function requires the path to a file containing the paths to each genome\sphinxhyphen{}scale model.

\sphinxAtStartPar
By default, the interaction will be defined by the log\sphinxhyphen{}ratio of simulated growth in the pair to simulated growth alone.


\subsection{Formatting the data}
\label{\detokenize{usage:formatting-the-data}}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Not Implemented
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Removes any species from the data that do not have interaction parameters in the full interaction network.
\end{sphinxadmonition}

\sphinxAtStartPar
We need to format the samples into a dict of dicts, or dict of tuples if predicitive power is to be assessed.

\sphinxAtStartPar
To format the data to compute friendliness scores with no known outcomes:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{format\PYGZus{}data} \PYG{k+kn}{import} \PYG{n}{format\PYGZus{}data}

\PYG{n}{experiment}\PYG{p}{,}\PYG{n}{scoretype} \PYG{o}{=} \PYG{n}{format\PYGZus{}data}\PYG{p}{(}\PYG{n}{path\PYGZus{}to\PYGZus{}table}\PYG{p}{,}\PYG{n}{full\PYGZus{}interaction\PYGZus{}network}\PYG{p}{,}\PYG{n}{nodes\PYGZus{}of\PYGZus{}interest}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The function requires the path to the table of abundances and the full interaction network so that species missing can be removed, and the name of the node(s) that we wish to assess for network friendliness.

\sphinxAtStartPar
Without known outcomes, \sphinxcode{\sphinxupquote{experiment}} will be a dict (keyed by sample name \sphinxhyphen{} the column headers of the abundance table)
of dicts (keyed by species), and \sphinxcode{\sphinxupquote{scoretype}} will be None

\sphinxAtStartPar
For assessment of the predictive power of the method, the path to a metadata file with known outcomes for each sample is required, as is the name of the known outcome column in that file (default \sphinxcode{\sphinxupquote{Score}}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{format\PYGZus{}data} \PYG{k+kn}{import} \PYG{n}{format\PYGZus{}data}

\PYG{n}{experiment}\PYG{p}{,}\PYG{n}{scoretype} \PYG{o}{=} \PYG{n}{format\PYGZus{}data}\PYG{p}{(}\PYG{n}{path\PYGZus{}to\PYGZus{}table}\PYG{p}{,}\PYG{n}{full\PYGZus{}interaction\PYGZus{}network}\PYG{p}{,}\PYG{n}{nodes\PYGZus{}of\PYGZus{}interest}\PYG{p}{,}\PYG{n}{known\PYGZus{}scores} \PYG{o}{=} \PYG{n}{path\PYGZus{}to\PYGZus{}metadata}\PYG{p}{,}\PYG{n}{score\PYGZus{}column} \PYG{o}{=} \PYG{n}{column\PYGZus{}of\PYGZus{}score}\PYG{p}{,}\PYG{n}{scoretype} \PYG{o}{=} \PYG{n}{score\PYGZus{}type}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
If the known outcome file is given, along with the name of the column of known outcome scores, \sphinxcode{\sphinxupquote{experiment}} will be a dict (keyed by sample name \sphinxhyphen{} the column headers of the abundance table) of
tuples with (known outcome score, dict of abundances). The dict of abundances is keyed by species. In this case, the function attempts to guess if the known scores are binary or continuous unless the
scoretype is given. If the scoretype is given as binary and the data are continuous, the function binarizes the data.

\sphinxAtStartPar
The second return value, \sphinxcode{\sphinxupquote{scoretype}} indicates the type of known outcome scores, either binary or continuous.


\subsection{Computing Friendliness Scores and Assessing Predictive Power}
\label{\detokenize{usage:computing-friendliness-scores-and-assessing-predictive-power}}
\sphinxAtStartPar
To compute friendliness scores for each sample on a node(s) of interest

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{score\PYGZus{}net} \PYG{k+kn}{import} \PYG{n}{network\PYGZus{}friendliness}

\PYG{n}{friendliness} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{k}{for} \PYG{n}{target\PYGZus{}node} \PYG{o+ow}{in} \PYG{n}{nodes\PYGZus{}of\PYGZus{}interest}\PYG{p}{:}
    \PYG{n}{friendliness}\PYG{p}{[}\PYG{n}{target\PYGZus{}node}\PYG{p}{]} \PYG{o}{=} \PYG{n}{network\PYGZus{}friendliness}\PYG{p}{(}\PYG{n}{experiment}\PYG{p}{,}\PYG{n}{full\PYGZus{}interaction\PYGZus{}network}\PYG{p}{,}\PYG{n}{target\PYGZus{}node}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The return value is a pandas dataframe that can be saved as a .csv file.

\sphinxAtStartPar
To assess the predictive power of the method (for friendliness on a single \sphinxcode{\sphinxupquote{target\_node}} in \sphinxcode{\sphinxupquote{nodes\_of\_interest}})

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{score\PYGZus{}net} \PYG{k+kn}{import} \PYG{n}{score\PYGZus{}net}

\PYG{n}{friendliness}\PYG{p}{,}\PYG{n}{predictive\PYGZus{}power} \PYG{o}{=} \PYG{n}{score\PYGZus{}net}\PYG{p}{(}\PYG{n}{experiment}\PYG{p}{,}\PYG{n}{full\PYGZus{}interaction\PYGZus{}network}\PYG{p}{,}\PYG{n}{target\PYGZus{}node}\PYG{p}{,}\PYG{n}{scoretype}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{predictive\_power}} is a dictionary of predictive power metrics, which depend on if the scoring is binary (in which case the ROC is used) or continuous (in which case correlation is used).


\subsection{Plotting the Results}
\label{\detokenize{usage:plotting-the-results}}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
I will probably add some functions to make plotting the results convenient.
\end{sphinxadmonition}


\subsection{Sensitivity to Parameters}
\label{\detokenize{usage:sensitivity-to-parameters}}
\sphinxAtStartPar
We also provide functionality to assess the sensitivity of the predictions to two types of perturbations.

\sphinxAtStartPar
The first is sensitivity to community composition, which we test using simulated knock\sphinxhyphen{}outs (i.e. computing friendliness scores with nodes removed).

\sphinxAtStartPar
The second is sensitivity to the interaction parameter values. We test this using a dynamical system for \(\frac{\partial x_i}{\partial a_{ij}}\). See {\hyperref[\detokenize{sensit::doc}]{\sphinxcrossref{\DUrole{doc}{Functions for Sensitivity Testing}}}}.

\sphinxstepscope


\chapter{Functions for Formatting OTU tables}
\label{\detokenize{format:functions-for-formatting-otu-tables}}\label{\detokenize{format::doc}}
\sphinxstepscope


\chapter{Functions for Making Interation Networks from GEMs}
\label{\detokenize{network_build:functions-for-making-interation-networks-from-gems}}\label{\detokenize{network_build::doc}}\index{check\_co\_occ() (in module make\_gem\_network)@\spxentry{check\_co\_occ()}\spxextra{in module make\_gem\_network}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{network_build:make_gem_network.check_co_occ}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{make\_gem\_network.}}\sphinxbfcode{\sphinxupquote{check\_co\_occ}}}{\emph{\DUrole{n}{experiment}}, \emph{\DUrole{n}{min\_ra}\DUrole{o}{=}\DUrole{default_value}{1e\sphinxhyphen{}06}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Check which nodes co\sphinxhyphen{}occurr in samples, so that we donâ€™t need to compute an interaction between those that donâ€™t
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{experiment}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} set of sets of nodes, as a dictionary of tuples with (known score,data) keyed by sample identifier. The data should be a dictionary of abundances keyed by node names.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{min\_ra}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} cutoff to use for presence/abscence of a node in a sample. Default 10**\sphinxhyphen{}6

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
NxN array with bool indicating if the pair co\sphinxhyphen{}occures, and list of nodes giving ordering of this array.

\sphinxlineitem{Return type}
\sphinxAtStartPar
array{[}bool{]},list{[}str{]}

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\chapter{Functions to Generate and Evaluate Predictions}
\label{\detokenize{scoring:functions-to-generate-and-evaluate-predictions}}\label{\detokenize{scoring::doc}}\index{network\_friendliness() (in module score\_net)@\spxentry{network\_friendliness()}\spxextra{in module score\_net}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{scoring:score_net.network_friendliness}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{score\_net.}}\sphinxbfcode{\sphinxupquote{network\_friendliness}}}{\emph{\DUrole{n}{experiment}}, \emph{\DUrole{n}{full\_net}}, \emph{\DUrole{n}{target\_node}}, \emph{\DUrole{n}{models}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{min\_ra}\DUrole{o}{=}\DUrole{default_value}{1e\sphinxhyphen{}06}}, \emph{\DUrole{n}{odeTrials}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This method computes the extent to which a set of sets of nodes are friendly to a particular node, using \sphinxcode{\sphinxupquote{friendlyNets}}.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{experiment}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Dictionary of samples. Each should be a dictionary of abundances keyed by node names. (Also supports dict of tuples as in {\hyperref[\detokenize{scoring:score_net.score_net}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{score\_net}}}}}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{full\_net}} (\sphinxstyleliteralemphasis{\sphinxupquote{pandas dataframe}}) \textendash{} Adjacency matrix of all interaction parameters between pairs of nodes in the entire experiment set.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{target\_node}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of node of interest. (must be in full\_net, need not be in sample \sphinxhyphen{} will be added to induced subgraph)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{models}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} list of models you wish to use for scoring. Leave as None for all 6.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{min\_ra}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} cutoff to use for presence/abscence of a node in a sample. Default 10**\sphinxhyphen{}6

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{odeTrials}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of ODE simulations in score estimation. If None, equal to number of non\sphinxhyphen{}zero taxa in a sample. Default None

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
friendliness scores for each sample and each model in models.

\sphinxlineitem{Return type}
\sphinxAtStartPar
pandas dataframe

\end{description}\end{quote}

\end{fulllineitems}

\index{score\_net() (in module score\_net)@\spxentry{score\_net()}\spxextra{in module score\_net}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{scoring:score_net.score_net}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{score\_net.}}\sphinxbfcode{\sphinxupquote{score\_net}}}{\emph{\DUrole{n}{experiment}}, \emph{\DUrole{n}{full\_net}}, \emph{\DUrole{n}{target\_node}}, \emph{\DUrole{n}{scoretype}}, \emph{\DUrole{n}{models}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{min\_ra}\DUrole{o}{=}\DUrole{default_value}{1e\sphinxhyphen{}06}}, \emph{\DUrole{n}{odeTrials}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This method computes the extent to which a set of sets of nodes are friendly to a particular node, using \sphinxcode{\sphinxupquote{friendlyNets}},
and \sphinxstylestrong{compares} this with a known effect of the community, which can be binary (good/bad) or continuous (e.g. relative abundance at a later time point) to compute predictive performance
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{experiment}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Dictionary of samples, each a tuple with (known score,data). The data should be a dictionary of abundances keyed by node names.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{full\_net}} (\sphinxstyleliteralemphasis{\sphinxupquote{pandas dataframe}}) \textendash{} Adjacency matrix of all interaction parameters between pairs of nodes in the entire experiment set.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{target\_node}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of node of interest. (must be in full\_net, need not be in sample \sphinxhyphen{} will be added to induced subgraph)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{scoretype}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Type of known score (\sphinxtitleref{b} for binary, \sphinxtitleref{c} for continuous)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{models}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} list of models you wish to use for scoring. Leave as None for all 6.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{min\_ra}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} cutoff to use for presence/abscence of a node in a sample. Default 10**\sphinxhyphen{}6

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{odeTrials}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of ODE simulations in score estimation. If None, equal to number of non\sphinxhyphen{}zero taxa in a sample. Default None

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
friendliness scores, predictive performance dictionary. If binary scoring, predictive performance is AUROC, ROC curves, and the mean AUROC.If continuous scoring, this is pearson correlation between friendliness score and known score, pearson p valule, kendall correlation, and kendall p value,spearman correlation, spearman p value. Correlation values are rescaled to {[}0,1{]} (from {[}\sphinxhyphen{}1,1{]}) to better match AUCROC scores.

\sphinxlineitem{Return type}
\sphinxAtStartPar
tuple of pandas dataframe, \{dict, dict, float\} OR tuple of pandas dataframe, \{dict,dict,dict,dict,dict,dict\}

\end{description}\end{quote}

\end{fulllineitems}

\index{score\_light() (in module score\_net)@\spxentry{score\_light()}\spxextra{in module score\_net}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{scoring:score_net.score_light}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{score\_net.}}\sphinxbfcode{\sphinxupquote{score\_light}}}{\emph{\DUrole{n}{experiment}}, \emph{\DUrole{n}{full\_net}}, \emph{\DUrole{n}{target\_node}}, \emph{\DUrole{n}{scoretype}}, \emph{\DUrole{n}{score\_model}}, \emph{\DUrole{n}{self\_inhibit}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{min\_ra}\DUrole{o}{=}\DUrole{default_value}{1e\sphinxhyphen{}06}}, \emph{\DUrole{n}{odeTrials}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{lvshift}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{cntbu}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{keepscores}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{KO}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This method computes the extent to which a set of sets of nodes are friendly to a particular node, using \sphinxcode{\sphinxupquote{friendlyNets}},
and compares this with a known effect of the community, which can be binary (good/bad) or continuous (e.g. relative abundance at a later time point). This version
only computes a score for a single type of model, but offers more parameter flexibility, including Shift and Self Inhibition in the {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.lotka_volterra_system}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Lotka\sphinxhyphen{}Volterra system}}}}}
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{experiment}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} set of sets of nodes, each a tuple with (known score,data). The data should be a dictionary of abundances keyed by node names.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{full\_net}} (\sphinxstyleliteralemphasis{\sphinxupquote{pandas dataframe}}) \textendash{} Adjacency matrix of all interaction parameters between pairs of nodes in the entire experiment set.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{target\_node}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of node of interest. (must be in full\_net, need not be in sample \sphinxhyphen{} will be added to induced subgraph)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{scoretype}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Type of known score (\sphinxtitleref{b} for binary, \sphinxtitleref{c} for continuous)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{score\_model}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Dynamical model to use for scoring. Choices LV, AntLV, InhibitLV, Replicator, NodeBalance, Stochastic, Composite, as detailed in {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.score_node}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{score\_node}}}}}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{self\_inhibit}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} extent to which the model should include self inhibition \sphinxhyphen{} self interaction terms (\(A_{ii}\)) will be set to negative \sphinxcode{\sphinxupquote{self\_inhibit}}. Default 0

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{min\_ra}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} cutoff to use for presence/abscence of a node in a sample. Default 10**\sphinxhyphen{}6

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{odeTrials}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of ODE simulations in score estimation. If None, equal to number of non\sphinxhyphen{}zero taxa in a sample. Default None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{lvshift}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Uniform (subtracted) modifier to interactions. Lotka\sphinxhyphen{}Volterra parameters will be {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.Adjacency}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Adjacency}}}}} \sphinxhyphen{} \sphinxcode{\sphinxupquote{shift}}. Default 0

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cntbu}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Whether or not to count the number of blow\sphinxhyphen{}ups in the simulations. Default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{keepscores}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Wether or not to return the friendliness scores. If False, only returns the predictive performance.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{KO}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Knockout nodes to remove from data

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
evaluation of prediction, as AUCROC or (kendall, spearman), optionally count of ODE blowups, and optionally sample ordering, friendliness scores (in that order)

\sphinxlineitem{Return type}
\sphinxAtStartPar
tuple float (or float,float), optional float, optional list{[}str{]}, optional array{[}float{]}

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\chapter{Functions for Sensitivity Testing}
\label{\detokenize{sensit:functions-for-sensitivity-testing}}\label{\detokenize{sensit::doc}}

\section{Functions for Lotka\sphinxhyphen{}Volterra Interaction Parameter Sensitivity Testing}
\label{\detokenize{sensit:functions-for-lotka-volterra-interaction-parameter-sensitivity-testing}}\index{get\_all\_sensitivity() (in module sensitivity)@\spxentry{get\_all\_sensitivity()}\spxextra{in module sensitivity}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sensit:sensitivity.get_all_sensitivity}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{sensitivity.}}\sphinxbfcode{\sphinxupquote{get\_all\_sensitivity}}}{\emph{\DUrole{n}{target\_node}}, \emph{\DUrole{n}{fnet}}, \emph{\DUrole{n}{entries}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}all\textquotesingle{}}}, \emph{\DUrole{n}{shift}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{self\_inhibit}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{numtrials}\DUrole{o}{=}\DUrole{default_value}{100}}, \emph{\DUrole{n}{nj}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{mxTime}\DUrole{o}{=}\DUrole{default_value}{1000}}, \emph{\DUrole{n}{wpts}\DUrole{o}{=}\DUrole{default_value}{40}}, \emph{\DUrole{n}{base\_we}\DUrole{o}{=}\DUrole{default_value}{1.5}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Compute sensitivity of a node to interaction parameters, and average over simulations. Computes weighted average, using \sphinxstyleemphasis{final} \sphinxcode{\sphinxupquote{wpts}} timepoints with increasing weight. Weight s is computed as \(b^s\) where \(b\) is \sphinxcode{\sphinxupquote{base\_we}} and then weights are rescaled to sum to 1.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{target\_node}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} name node of interest (nodes are usually named with str, but can be named with other objects, most commonly int equal to node index.)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fnet}} ({\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{friendlyNet}}}}}) \textendash{} network of interactions for the model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{entries}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Which interaction parameters to test sensitivity to (names). If â€˜allâ€™, tests for every parameter. Otherwise, should be a list of tuples of names (source,target). Default â€˜allâ€™

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shift}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Uniform (subtracted) modifier to interactions. Lotka\sphinxhyphen{}Volterra parameters will be {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.Adjacency}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Adjacency}}}}} \sphinxhyphen{} \sphinxcode{\sphinxupquote{shift}}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{self\_inhibit}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} extent to which the model should include self inhibition \sphinxhyphen{} self interaction terms (\(a_{ii}\)) will be set to \sphinxhyphen{}\sphinxcode{\sphinxupquote{self\_inhibit}}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{numtrials}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of simulations to average over

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nj}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of trials to run in parallel (using joblib)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mxTime}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} time length of simulations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{wpts}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of time\sphinxhyphen{}points in each simulation to average over (will be final time\sphinxhyphen{}points). Default 40

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{base\_we}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} base for weights of time\sphinxhyphen{}averaging \sphinxhyphen{} should be \(>1\) for increasing weight, equal to 1 for uniform weight on last \sphinxcode{\sphinxupquote{wpt}} time\sphinxhyphen{}points. Default 1.5

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Average value of \(\partial x_i/\partial a_{kl}\) averaged first over time points in each simulation and next over simulations. If \sphinxcode{\sphinxupquote{pars}} == â€˜allâ€™, returns NxN array indexed by {[}source,target{]}. Otherwise, returns 1d array corresponding to â€˜parsâ€™

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_all\_sensitivity\_single\_trajectory() (in module sensitivity)@\spxentry{get\_all\_sensitivity\_single\_trajectory()}\spxextra{in module sensitivity}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sensit:sensitivity.get_all_sensitivity_single_trajectory}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{sensitivity.}}\sphinxbfcode{\sphinxupquote{get\_all\_sensitivity\_single\_trajectory}}}{\emph{\DUrole{n}{fnet}}, \emph{\DUrole{n}{i}}, \emph{\DUrole{n}{shift}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{self\_inhibit}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{weights}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{mxTime}\DUrole{o}{=}\DUrole{default_value}{1000}}, \emph{\DUrole{n}{pars}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}all\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Compute sensitivity of node i to every interaction parameter. To do this, we need to solve an ODE that arises from the chain rule. Because we can reuse the solution to the lotka\sphinxhyphen{}volerra
system, we donâ€™t want to repeatedly call get\_sensitivity on a each parameter.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fnet}} ({\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{friendlyNet}}}}}) \textendash{} network of interactions for the model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{i}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} index of node of interest

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shift}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Uniform (subtracted) modifier to interactions. Lotka\sphinxhyphen{}Volterra parameters will be {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.Adjacency}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Adjacency}}}}} \sphinxhyphen{} \sphinxcode{\sphinxupquote{shift}}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{self\_inhibit}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} extent to which the model should include self inhibition \sphinxhyphen{} self interaction terms (\(a_{ii}\)) will be set to \sphinxhyphen{}\sphinxcode{\sphinxupquote{self\_inhibit}}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{weights}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} weights for time\sphinxhyphen{}points of the ODE solution. This allows us to weight the later timepoints (closer to equilibrium) higher, or not, with some granularity. Default unweighted.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mxTime}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} time length of simulations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pars}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Which interaction parameters to test sensitivity to. If â€˜allâ€™, tests for every parameter. Otherwise, should be a list of tuples of indices (source,target). Default â€˜allâ€™

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
(possibly weighted) average value of \(\partial x_i/\partial a_{kl}\) over time points in simulation for each. If \sphinxcode{\sphinxupquote{pars}} == â€˜allâ€™, returns NxN array indexed by {[}source,target{]}. Otherwise, returns 1d array corresponding to â€˜parsâ€™

\sphinxlineitem{Return type}
\sphinxAtStartPar
array{[}float{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_sensitivity\_single\_trajectory() (in module sensitivity)@\spxentry{get\_sensitivity\_single\_trajectory()}\spxextra{in module sensitivity}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sensit:sensitivity.get_sensitivity_single_trajectory}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{sensitivity.}}\sphinxbfcode{\sphinxupquote{get\_sensitivity\_single\_trajectory}}}{\emph{\DUrole{n}{fnet}}, \emph{\DUrole{n}{i}}, \emph{\DUrole{n}{k}}, \emph{\DUrole{n}{l}}, \emph{\DUrole{n}{soln}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{shift}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{self\_inhibit}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{weights}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{mxTime}\DUrole{o}{=}\DUrole{default_value}{1000}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Compute sensitivity of node i to parameter \(a_{kl}\). To do this, we need to solve an ODE that arises from the chain rule.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fnet}} ({\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{friendlyNet}}}}}) \textendash{} network of interactions for the model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{i}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} index of node of interest

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} source node of interaction of interest

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{l}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} target node of interaction of interest

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{soln}} (\sphinxstyleliteralemphasis{\sphinxupquote{scipy.integrate.solve\_ivp object}}) \textendash{} solution to lotka\sphinxhyphen{}volterra system \sphinxstyleemphasis{must use same shift and self\_inhibit parameters}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shift}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Uniform (subtracted) modifier to interactions. Lotka\sphinxhyphen{}Volterra parameters will be {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.Adjacency}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Adjacency}}}}} \sphinxhyphen{} \sphinxcode{\sphinxupquote{shift}}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{self\_inhibit}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} extent to which the model should include self inhibition \sphinxhyphen{} self interaction terms (\(a_{ii}\)) will be set to \sphinxhyphen{}\sphinxcode{\sphinxupquote{self\_inhibit}}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{weights}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} weights for time\sphinxhyphen{}points of the ODE solution. This allows us to weight the later timepoints (closer to equilibrium) higher, or not, with some granularity. Default unweighted.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mxTime}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} time length of simulations

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
(possibly weighted) average value of \(\partial x_i/\partial a_{kl}\) over time points in simulation.

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{sense\_kl() (in module sensitivity)@\spxentry{sense\_kl()}\spxextra{in module sensitivity}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sensit:sensitivity.sense_kl}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{sensitivity.}}\sphinxbfcode{\sphinxupquote{sense\_kl}}}{\emph{\DUrole{n}{t}}, \emph{\DUrole{n}{ps}}, \emph{\DUrole{n}{x}}, \emph{\DUrole{n}{k}}, \emph{\DUrole{n}{l}}, \emph{\DUrole{n}{net}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Dynamical system for senstivity \(\partial x_i/\partial a_{kl}\) for a Lotka\sphinxhyphen{}Volterra interaction parameter.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{t}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} time in simulation

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ps}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} state in simulatoin

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{function}}) \textendash{} Lotka\sphinxhyphen{}Volterra solution (dense output of scipy.integrate.solve\_ivp)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} index of source of interaction

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{l}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} index of target of interaction

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{net}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} adjacency matrix for Lotka\sphinxhyphen{}Volterra system

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
right\sphinxhyphen{}hand side of dynamical system

\sphinxlineitem{Return type}
\sphinxAtStartPar
array{[}float{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{compute\_j() (in module sensitivity)@\spxentry{compute\_j()}\spxextra{in module sensitivity}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sensit:sensitivity.compute_j}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{sensitivity.}}\sphinxbfcode{\sphinxupquote{compute\_j}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{net}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Helper function to compute a term in the dynamical system defined by {\hyperref[\detokenize{sensit:sensitivity.sense_kl}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{sense\_kl}}}}}.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Lotka\sphinxhyphen{}Volterra state at time t

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{net}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} adjacency matrix for Lotka\sphinxhyphen{}Volterra system

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
term in RHS

\sphinxlineitem{Return type}
\sphinxAtStartPar
array{[}float{]}

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\chapter{The FriendlyNets class}
\label{\detokenize{friendlynets:the-friendlynets-class}}\label{\detokenize{friendlynets::doc}}
\sphinxAtStartPar
This is the core class of the method, a network class built from an adjacency matrix that contains methods for measuring friendliness to the nodes.
\index{friendlyNet (class in friendlyNet)@\spxentry{friendlyNet}\spxextra{class in friendlyNet}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{friendlyNet.}}\sphinxbfcode{\sphinxupquote{friendlyNet}}}{\emph{\DUrole{n}{adj}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Network class designed for testing how positive a directed network is for a node. Provides several ways to score the networkâ€™s friendliness for a given node. By friendliness,
we mean some measure of how much the network promotes/inhibits a node based on a choice of interaction model represented by the graph (e.g. Lotka\sphinxhyphen{}Volterra or Diffusion).
Rescales the adjacency matrix so that all weights are in \([0,1]\)
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{adj}} (\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{N}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{N}}\sphinxstyleliteralemphasis{\sphinxupquote{) }}\sphinxstyleliteralemphasis{\sphinxupquote{array}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Adjacency matrix of the graph.

\end{description}\end{quote}
\index{Adjacency (friendlyNet.friendlyNet attribute)@\spxentry{Adjacency}\spxextra{friendlyNet.friendlyNet attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.Adjacency}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{Adjacency}}}
\pysigstopsignatures
\sphinxAtStartPar
Network adjacency matrix, rescaled so that all weights are in \([0,1]\)

\end{fulllineitems}

\index{NodeNames (friendlyNet.friendlyNet attribute)@\spxentry{NodeNames}\spxextra{friendlyNet.friendlyNet attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.NodeNames}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{NodeNames}}}
\pysigstopsignatures
\sphinxAtStartPar
List of names of the nodes, corresponding to ordering of adjacency matrix

\end{fulllineitems}

\index{InDegree (friendlyNet.friendlyNet attribute)@\spxentry{InDegree}\spxextra{friendlyNet.friendlyNet attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.InDegree}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{InDegree}}}
\pysigstopsignatures
\sphinxAtStartPar
Total weight of edges into each node

\end{fulllineitems}

\index{OutDegree (friendlyNet.friendlyNet attribute)@\spxentry{OutDegree}\spxextra{friendlyNet.friendlyNet attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.OutDegree}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{OutDegree}}}
\pysigstopsignatures
\sphinxAtStartPar
Total weight of edges out of each node

\end{fulllineitems}

\index{NodeScores (friendlyNet.friendlyNet attribute)@\spxentry{NodeScores}\spxextra{friendlyNet.friendlyNet attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.NodeScores}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{NodeScores}}}
\pysigstopsignatures
\sphinxAtStartPar
Pandas DataFrame of friendliness scores for each node for a set of chosen dynamical models.

\end{fulllineitems}

\index{EdgeList (friendlyNet.friendlyNet attribute)@\spxentry{EdgeList}\spxextra{friendlyNet.friendlyNet attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.EdgeList}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{EdgeList}}}
\pysigstopsignatures
\sphinxAtStartPar
Pandas DataFrame of edges (with weights) for the network that can be easily saved and loaded into cytoscape. See {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.make_edge_list}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{make\_edge\_list}}}}}

\end{fulllineitems}

\index{make\_edge\_list() (friendlyNet.friendlyNet method)@\spxentry{make\_edge\_list()}\spxextra{friendlyNet.friendlyNet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.make_edge_list}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{make\_edge\_list}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Create a list of edges with columns:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Source

\item {} 
\sphinxAtStartPar
Target

\item {} 
\sphinxAtStartPar
Weight

\item {} 
\sphinxAtStartPar
ABS\_Weight (absolute value)

\item {} 
\sphinxAtStartPar
Sign\_Weight

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Modifies}
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.EdgeList}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{EdgeList}}}}}

\end{itemize}
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{lotka\_volterra\_system() (friendlyNet.friendlyNet method)@\spxentry{lotka\_volterra\_system()}\spxextra{friendlyNet.friendlyNet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.lotka_volterra_system}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{lotka\_volterra\_system}}}{\emph{\DUrole{n}{t}}, \emph{\DUrole{n}{s}}, \emph{\DUrole{n}{shift}}, \emph{\DUrole{n}{self\_inhibit}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Right\sphinxhyphen{}Hand side of generalized Lotka\sphinxhyphen{}Volterra dynamical system, using {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.Adjacency}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Adjacency}}}}} for interactions:
\begin{equation*}
\begin{split}\dot{x}_i = x_i(1+\sum_{j=1}^N a_{ij} x_j)\end{split}
\end{equation*}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{t}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} time in simulation

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{s}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} State of simulation (species abundance)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shift}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Uniform (subtracted) modifier to interactions. Lotka\sphinxhyphen{}Volterra parameters will be {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.Adjacency}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Adjacency}}}}} \sphinxhyphen{} \sphinxcode{\sphinxupquote{shift}}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{self\_inhibit}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} extent to which the model should include self inhibition \sphinxhyphen{} self interaction terms (\(a_{ii}\)) will be set to \sphinxhyphen{}\sphinxcode{\sphinxupquote{self\_inhibit}}

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
value of vector field at t,s

\sphinxlineitem{Return type}
\sphinxAtStartPar
array{[}float{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{solve\_lotka\_volterra() (friendlyNet.friendlyNet method)@\spxentry{solve\_lotka\_volterra()}\spxextra{friendlyNet.friendlyNet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.solve_lotka_volterra}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{solve\_lotka\_volterra}}}{\emph{\DUrole{n}{s0}}, \emph{\DUrole{n}{T}}, \emph{\DUrole{n}{shift}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{bup}\DUrole{o}{=}\DUrole{default_value}{1000}}, \emph{\DUrole{n}{self\_inhibit}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Solves the generalized Lotka\sphinxhyphen{}Volterra dynamical system, using {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.Adjacency}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Adjacency}}}}} for interactions
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{s0}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Inital state of simulation (species abundance)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{T}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Simulation length

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shift}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Uniform (subtracted) modifier to interactions. Lotka\sphinxhyphen{}Volterra parameters will be {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.Adjacency}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Adjacency}}}}} \sphinxhyphen{} \sphinxcode{\sphinxupquote{shift}}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bup}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} maximum abundance to allow in simulation. If any state variable reaches this value, it is assumed that the simulation has exhibited finite\sphinxhyphen{}time blowup and the simulation is stopped.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{self\_inhibit}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} extent to which the model should include self inhibition \sphinxhyphen{} self interaction terms (\(A_{ii}\)) will be set to negative \sphinxcode{\sphinxupquote{self\_inhibit}}

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Solution to the Lotka\sphinxhyphen{}Volterra dynamics

\sphinxlineitem{Return type}
\sphinxAtStartPar
scipy.integrate.solve\_ivp solution

\end{description}\end{quote}

\end{fulllineitems}

\index{lotka\_volterra\_score\_single() (friendlyNet.friendlyNet method)@\spxentry{lotka\_volterra\_score\_single()}\spxextra{friendlyNet.friendlyNet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.lotka_volterra_score_single}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{lotka\_volterra\_score\_single}}}{\emph{\DUrole{n}{node}}, \emph{\DUrole{n}{mxTime}\DUrole{o}{=}\DUrole{default_value}{100}}, \emph{\DUrole{n}{shift}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{self\_inhibit}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Uses the Lotka\sphinxhyphen{}Volterra dynamical system to determine the networkâ€™s friendliness to a particular node. Solves the system using {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.solve_lotka_volterra}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{solve\_lotka\_volterra}}}}}.
Solves the Lotka\sphinxhyphen{}Volterra system with random initial conditions and computes a score. The score is based on final relative abundance, but for finer scoring we also account for time to extinction
and time to domination (e.g. relative abundance near 1). The score is computed as

\sphinxAtStartPar
where \(T_e\) is the proportion of the time internal that the species is \sphinxstyleemphasis{not} extinct, \(T_d\) is the proportion of the time interval that the species \sphinxstyleemphasis{is} dominant, and \(r\) is the final relative abundance of the species.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} name or index of node

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mxTime}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} time length of simulations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shift}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Uniform (subtracted) modifier to interactions. Lotka\sphinxhyphen{}Volterra parameters will be {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.Adjacency}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Adjacency}}}}} \sphinxhyphen{} \sphinxcode{\sphinxupquote{shift}}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{self\_inhibit}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} extent to which the model should include self inhibition \sphinxhyphen{} self interaction terms (\(A_{ii}\)) will be set to negative \sphinxcode{\sphinxupquote{self\_inhibit}}

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Friendliness of the network to the node, according to the single Lotka\sphinxhyphen{}Volterra simulation, and the status of the ODE solution

\sphinxlineitem{Return type}
\sphinxAtStartPar
tuple{[}float,str{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{lotka\_volterra\_score() (friendlyNet.friendlyNet method)@\spxentry{lotka\_volterra\_score()}\spxextra{friendlyNet.friendlyNet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.lotka_volterra_score}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{lotka\_volterra\_score}}}{\emph{\DUrole{n}{node}}, \emph{\DUrole{n}{mxTime}\DUrole{o}{=}\DUrole{default_value}{100}}, \emph{\DUrole{n}{numtrials}\DUrole{o}{=}\DUrole{default_value}{1000}}, \emph{\DUrole{n}{nj}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{}1}}, \emph{\DUrole{n}{shift}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{self\_inhibit}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{cntbu}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Provides a score using repeated trials of the Lotka\sphinxhyphen{}Volterra system. Scores using {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.lotka_volterra_score_single}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{lotka\_volterra\_score\_single}}}}}
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} name or index of node

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mxTime}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} time length of simulations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{numtrials}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of ODE solutions and corresponding scores to compute

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nj}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of parrallel simulations to run concurrently (uses joblib)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shift}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Uniform (subtracted) modifier to interactions. Lotka\sphinxhyphen{}Volterra parameters will be {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.Adjacency}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Adjacency}}}}} \sphinxhyphen{} \sphinxcode{\sphinxupquote{shift}}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{self\_inhibit}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} extent to which the model should include self inhibition \sphinxhyphen{} self interaction terms (\(A_{ii}\)) will be set to negative \sphinxcode{\sphinxupquote{self\_inhibit}}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cntbu}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Whether or not to count the number of blow\sphinxhyphen{}ups in the simulations

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
score from {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.lotka_volterra_score_single}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{lotka\_volterra\_score\_single}}}}} averaged over all trials, optinoally number of blowups in simulation

\sphinxlineitem{Return type}
\sphinxAtStartPar
float,int

\end{description}\end{quote}

\end{fulllineitems}

\index{replicator\_system() (friendlyNet.friendlyNet method)@\spxentry{replicator\_system()}\spxextra{friendlyNet.friendlyNet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.replicator_system}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{replicator\_system}}}{\emph{\DUrole{n}{t}}, \emph{\DUrole{n}{s}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Right\sphinxhyphen{}Hand side of replicator dynamical system, using {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.Adjacency}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Adjacency}}}}} for interactions:
\begin{equation*}
\begin{split}\dot{x}_i = x_i(\sum_{j=1}^N a_{ij} x_j - x^TAx)\end{split}
\end{equation*}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{t}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} time in simulation

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{s}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} State of simulation (species abundance)

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
value of vector field at t,s

\sphinxlineitem{Return type}
\sphinxAtStartPar
array{[}float{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{solve\_replicator() (friendlyNet.friendlyNet method)@\spxentry{solve\_replicator()}\spxextra{friendlyNet.friendlyNet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.solve_replicator}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{solve\_replicator}}}{\emph{\DUrole{n}{s0}}, \emph{\DUrole{n}{T}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Solves the replicator dynamical system, using {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.Adjacency}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Adjacency}}}}} for interactions
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{s0}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Inital state of simulation (species abundance)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{T}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Simulation length

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Solution to the replicator dynamics

\sphinxlineitem{Return type}
\sphinxAtStartPar
scipy.integrate.solve\_ivp solution

\end{description}\end{quote}

\end{fulllineitems}

\index{replicator\_score\_single() (friendlyNet.friendlyNet method)@\spxentry{replicator\_score\_single()}\spxextra{friendlyNet.friendlyNet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.replicator_score_single}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{replicator\_score\_single}}}{\emph{\DUrole{n}{node}}, \emph{\DUrole{n}{mxTime}\DUrole{o}{=}\DUrole{default_value}{100}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Uses the replicator dynamical system to determine the networkâ€™s friendliness to a particular node. Solves the system using {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.solve_replicator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{solve\_replicator}}}}}.
Solves the replicator system with random initial conditions and computes a score. The score is based on final relative abundance, but for finer scoring we also account for time to extinction
and time to domination (e.g. relative abundance near 1). The score is computed as

\sphinxAtStartPar
where \(T_e\) is the proportion of the time internal that the species is \sphinxstyleemphasis{not} extinct, \(T_d\) is the proportion of the time interval that the species \sphinxstyleemphasis{is} dominant, and \(r\) is the final relative abundance of the species.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} name or index of node

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mxTime}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} time length of simulations

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Friendliness of the network to the node, according to the single replicator simulation, and the status of the ODE solution

\sphinxlineitem{Return type}
\sphinxAtStartPar
tuple{[}float,str{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{replicator\_score() (friendlyNet.friendlyNet method)@\spxentry{replicator\_score()}\spxextra{friendlyNet.friendlyNet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.replicator_score}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{replicator\_score}}}{\emph{\DUrole{n}{node}}, \emph{\DUrole{n}{mxTime}\DUrole{o}{=}\DUrole{default_value}{100}}, \emph{\DUrole{n}{numtrials}\DUrole{o}{=}\DUrole{default_value}{1000}}, \emph{\DUrole{n}{nj}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{}1}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Provides a score using repeated trials of the replicator system. Scores using {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.replicator_score_single}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{replicator\_score\_single}}}}}
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} name or index of node

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mxTime}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} time length of simulations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{numtrials}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of ODE solutions and corresponding scores to compute

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nj}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of parrallel simulations to run concurrently (uses joblib)

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
score from {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.lotka_volterra_score_single}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{lotka\_volterra\_score\_single}}}}} averaged over all trials

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{node\_balanced\_score() (friendlyNet.friendlyNet method)@\spxentry{node\_balanced\_score()}\spxextra{friendlyNet.friendlyNet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.node_balanced_score}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{node\_balanced\_score}}}{\emph{\DUrole{n}{node}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Provides a score based on the linear system

\sphinxAtStartPar
where \(L= A^T-D\) is the graph laplance matrix for the graph after weights have been rescaled to the interval \([0,1]\).
This dynamical system arises from the notion of node\sphinxhyphen{}balancing the graph. Because this is linear, we can use the dominant eigenvector of the
laplacian to compute equilibrium.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} name or index of node

\sphinxlineitem{Returns}
\sphinxAtStartPar
Value of node in dominant eigenvector (i.e. equilibrium solution)

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{node\_balanced\_system() (friendlyNet.friendlyNet method)@\spxentry{node\_balanced\_system()}\spxextra{friendlyNet.friendlyNet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.node_balanced_system}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{node\_balanced\_system}}}{\emph{\DUrole{n}{T}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Function to provide a simulation for the node\sphinxhyphen{}balancing linear system

\sphinxAtStartPar
where \(L= A^T-D\) is the graph laplance matrix for the graph after weights have been rescaled to the interval \([0,1]\).
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{T}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} End time of simulation

\sphinxlineitem{Returns}
\sphinxAtStartPar
Solution to the node balance dynamics

\sphinxlineitem{Return type}
\sphinxAtStartPar
scipy.integrate.solve\_ivp solution

\end{description}\end{quote}

\end{fulllineitems}

\index{stochastic\_score() (friendlyNet.friendlyNet method)@\spxentry{stochastic\_score()}\spxextra{friendlyNet.friendlyNet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.stochastic_score}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{stochastic\_score}}}{\emph{\DUrole{n}{node}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Provides a score based on the linear system that simulates concurrent random walks (or, equivalently, diffusion) on the graph.
We rescale the adjacency matrix to build a stochastic matrix that represents the transition probabilities in a random walk on the graph.
The eigenvectors of this matrix provide a stationary distribution for the cuncurrent random walks.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} name or index of node

\sphinxlineitem{Returns}
\sphinxAtStartPar
Value of node in stationary distribution

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{score\_node() (friendlyNet.friendlyNet method)@\spxentry{score\_node()}\spxextra{friendlyNet.friendlyNet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.score_node}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{score\_node}}}{\emph{\DUrole{n}{node}}, \emph{\DUrole{n}{scores}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{odeTrials}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Function to score a node using a set of scores. Choose any list of the following:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{LV} The {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.lotka_volterra_system}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Lotka\sphinxhyphen{}Volterra system}}}}}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{InhibitLV} {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.lotka_volterra_system}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Lotka\sphinxhyphen{}Volterra system}}}}} with self inhibition = 1

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{AntLV} The {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.lotka_volterra_system}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Lotka\sphinxhyphen{}Volterra system}}}}} with all interactions shifted by \sphinxhyphen{}1 to make them antagonistic.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Replicator} The {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.replicator_system}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{replicator equation dynamics}}}}}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{NodeBalance} The linear {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.node_balanced_score}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{node balancing dynamical system}}}}}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Stochastic} The linear {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.stochastic_score}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{random walk dynamical system}}}}}

\end{itemize}

\sphinxAtStartPar
A composite score will be included, which is simply the mean of each score included.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name or index of node

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{scores}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} list of score types you wish to use. Leave as None for all 6.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{odeTrials}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of simulations of the Lotka\sphinxhyphen{}Volterra and replicator dynamics to use to estimate the score. Leave as None for number of trials equal to number of nodes in the network.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Dictionary of scores keyed by score type.

\sphinxlineitem{Trype}
\sphinxAtStartPar
dict{[}str,float{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{score\_all\_nodes() (friendlyNet.friendlyNet method)@\spxentry{score\_all\_nodes()}\spxextra{friendlyNet.friendlyNet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.score_all_nodes}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{score\_all\_nodes}}}{\emph{\DUrole{n}{scores}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{odeTrials}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Function to score all nodes using a set of scores. Choose any list of the following:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{LV} The {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.lotka_volterra_system}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Lotka\sphinxhyphen{}Volterra system}}}}}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{InhibitLV} {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.lotka_volterra_system}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Lotka\sphinxhyphen{}Volterra system}}}}} with self inhibition = 1

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{AntLV} The {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.lotka_volterra_system}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Lotka\sphinxhyphen{}Volterra system}}}}} with all interactions shifted by \sphinxhyphen{}1 to make them antagonistic.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Replicator} The {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.replicator_system}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{replicator equation dynamics}}}}}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{NodeBalance} The linear {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.node_balanced_score}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{node balancing dynamical system}}}}}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Stochastic} The linear {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.stochastic_score}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{random walk dynamical system}}}}}

\end{itemize}

\sphinxAtStartPar
A composite score will be included, which is simply the mean of each score included.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{scores}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} list of score types you wish to use. Leave as None for all 6.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{odeTrials}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of simulations of the Lotka\sphinxhyphen{}Volterra and replicator dynamics to use to estimate the score. Leave as None for number of trials equal to number of nodes in the network.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Table of scores for each node and score type chosen

\sphinxlineitem{Trype}
\sphinxAtStartPar
pandas dataframe

\end{description}\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{Modifies}
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.NodeScores}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{NodeScores}}}}}

\end{itemize}

\end{fulllineitems}


\end{fulllineitems}


\begin{sphinxthebibliography}{KSC22}
\bibitem[KSC22]{index:id3}
\sphinxAtStartPar
Minsuk Kim, Jaeyun Sung, and Nicholas Chia. Resource\sphinxhyphen{}allocation constraint governs structure and function of microbial communities in metabolic modeling. \sphinxstyleemphasis{Metabolic Engineering}, 70:12\textendash{}22, 2022.
\end{sphinxthebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{FriendlyNets}
\date{Aug 03, 2023}
\release{0.2}
\author{James D.\@{} Brunner}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxAtStartPar
FriendlyNets provides a method for assessing the promotion/inhibition effect on a microbe of a microbial community using a network of community interactions. At its core, FriendlyNets judges how much a network
promotes or inhibits one of its nodes. It does this by assuming a set of dynamical systems represented by the network and using the resulting dynamics. FriendlyNets is also packaged with functions for generating
a network from a set of genome\sphinxhyphen{}scale metabolic models (commonly called GSMs or GEMs) by simulating pairwise growth using the methods from {[}\hyperlink{cite.index:id3}{KSC22}{]}.

\sphinxAtStartPar
Check out the {\hyperref[\detokenize{usage::doc}]{\sphinxcrossref{\DUrole{doc}{Usage}}}} section for further information, including how to
{\hyperref[\detokenize{usage:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{install}}}} the project.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
This project is under active development.
\end{sphinxadmonition}

\sphinxstepscope


\chapter{Usage}
\label{\detokenize{usage:usage}}\label{\detokenize{usage::doc}}

\section{Installation}
\label{\detokenize{usage:installation}}\label{\detokenize{usage:id1}}
\sphinxAtStartPar
To use FriendlyNets, clone from github:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }clone\PYG{+w}{ }https://github.com/jdbrunner/friendlyNets.git
\end{sphinxVerbatim}

\sphinxAtStartPar
(We plan to add pip installation in the future)

\sphinxAtStartPar
You will also need to add the directory to your python path, for example using

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{expanduser}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZti{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}\PYG{n}{location}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{friendlyNets}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{location}} is the path to the folder that you cloned friendlyNets into.

\sphinxAtStartPar
\sphinxstylestrong{Dependencies}

\sphinxAtStartPar
We use \sphinxhref{https://joblib.readthedocs.io/en/latest/}{joblib} for parallel computing.

\sphinxAtStartPar
Our implementation of SteadyComX uses \sphinxhref{https://www.gurobi.com/documentation/9.5/}{Gurobi} and gurobi’s python package for joint FBA, and expects \sphinxhref{https://opencobra.github.io/cobrapy/}{cobrapy} models as input.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Unfortunately, we do not currently have access to a CPLEX license in order to implement CPLEX as a solver option.
\end{sphinxadmonition}


\section{Using the Method for a Set of Samples}
\label{\detokenize{usage:using-the-method-for-a-set-of-samples}}
\sphinxAtStartPar
FriendlyNets is designed to predict the invasion of a single species into a community. It is designed around microbiome studies, but written more generally so that nodes can be anything as long as interaction parameters between
the nodes are known. For microbiome studies, we provide a method to generate the set of interaction parameters from a set of genome\sphinxhyphen{}scale metabolic models which must be provided by the user.

\sphinxAtStartPar
We assume that the user has a table in .csv format with rows indexed by species of interest and columns indexed by sample name that contains abundance data for each species in each sample (relative or absolute). Additionally, if an assessment of the predictive power of the method is desired (which may indicate
the extent to which experimental outcome depends on network effects), a metadata file must be provided as .csv with rows indexed by sample name and a column indicating experimental outcome of an invasion experiment


\subsection{Formatting the data}
\label{\detokenize{usage:formatting-the-data}}
\sphinxAtStartPar
We need to format the samples into a specific (not very user\sphinxhyphen{}friendly) form for use with the method. We provide {\hyperref[\detokenize{format::doc}]{\sphinxcrossref{\DUrole{doc}{Function for Formatting OTU tables}}}} so that the user can provide data in an easier way.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Often, a significant amount of pre\sphinxhyphen{}processing is required to arrange the data into the required format for our formatting function (e.g. splitting into seperate experiments, etc.). We have provided three examples in the in
\sphinxcode{\sphinxupquote{Example}} folder.
\end{sphinxadmonition}

\sphinxAtStartPar
To format the data to compute friendliness scores with no known outcomes:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{format\PYGZus{}data} \PYG{k+kn}{import} \PYG{n}{format\PYGZus{}data}

\PYG{n}{experiment}\PYG{p}{,}\PYG{n}{scoretype}\PYG{p}{,}\PYG{n}{coverage} \PYG{o}{=} \PYG{n}{format\PYGZus{}data}\PYG{p}{(}\PYG{n}{otu\PYGZus{}dataframe}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The function requires the abundance data table (as pandas dataframe) and returns a set of samples formatted for use in downstream analysis. It also returns two variables that are not relevant if called as above.

\sphinxAtStartPar
Without known outcomes, \sphinxcode{\sphinxupquote{experiment}} will be a dict (keyed by sample name \sphinxhyphen{} the column headers of the abundance table)
of dicts (keyed by species), and \sphinxcode{\sphinxupquote{scoretype}} will be None. Coverage will be a dictionary simply indicating that the entire index of the abundance data table is included.

\sphinxAtStartPar
For assessment of the predictive power of the method, the path to a metadata file with known outcomes for each sample is required, as is the name of the known outcome column in that file (default \sphinxcode{\sphinxupquote{Score}}). Furthermore,
the function can filter the data, including only a subset of the index of the abundance table. This can be used to filter out taxa for which no genome scale model is available.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{format\PYGZus{}data} \PYG{k+kn}{import} \PYG{n}{format\PYGZus{}data}

\PYG{n}{experiment}\PYG{p}{,}\PYG{n}{scoretype}\PYG{p}{,}\PYG{n}{coverage} \PYG{o}{=} \PYG{n}{format\PYGZus{}data}\PYG{p}{(}\PYG{n}{otu\PYGZus{}dataframe}\PYG{p}{,}\PYG{n}{sample\PYGZus{}metadata} \PYG{o}{=} \PYG{n}{metadata\PYGZus{}dataframe}\PYG{p}{,}\PYG{n}{score\PYGZus{}col} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Score}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{included\PYGZus{}otus} \PYG{o}{=} \PYG{n}{taxa\PYGZus{}with\PYGZus{}models}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
If the known outcome file is given, along with the name of the column of known outcome scores, \sphinxcode{\sphinxupquote{experiment}} will be a dict (keyed by sample name \sphinxhyphen{} the column headers of the abundance table) of
tuples with (known outcome score, dict of abundances). The dict of abundances is keyed by species. In this case, the function attempts to guess if the known scores are binary or continuous unless the
scoretype is given. If the scoretype is given as binary and the data are continuous, the function binarizes the data.

\sphinxAtStartPar
The second return value, \sphinxcode{\sphinxupquote{scoretype}} indicates the type of known outcome scores, either binary or continuous.

\sphinxAtStartPar
The third return value, \sphinxcode{\sphinxupquote{coverage}} is a dict of dicts indicating the coverage of the samples by the included otus. For each sample, the corresponding dictionary has the keys:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Coverage} : The total relative abundance of the otus included.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{NumberMissing} : The number of otus not included.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{MajorMissing} : The otus not included with the highest relative abundance (any otus with \(\geq 80%\) of the highest missing relative abundance)

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{AllMissing} : List of all the otus not included.

\end{itemize}


\subsection{Creating the full network}
\label{\detokenize{usage:creating-the-full-network}}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Optional: A network can instead be loaded as a pandas DataFrame with nodes and columns being names of the species in the data, formatted
as \sphinxcode{\sphinxupquote{Network.loc{[}m\_1,m\_2{]}}} contains the interaction with source \sphinxcode{\sphinxupquote{m\_1}} and target \sphinxcode{\sphinxupquote{m\_2}}.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
This guide assumes that the user has GSMs corresponding to the organisms in their samples. In the \sphinxcode{\sphinxupquote{Examples}}, we provide examples of how one might construct these models (\sphinxcode{\sphinxupquote{make\_models.py}}) using \sphinxhref{https://modelseed.org/}{modelSEED}.
\end{sphinxadmonition}

\sphinxAtStartPar
For microbiome data paired with a set of genome\sphinxhyphen{}scale metabolic models, the method creates network of interactions for all co\sphinxhyphen{}occurring taxa that have an associated user\sphinxhyphen{}provided genome\sphinxhyphen{}scale model.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{make\PYGZus{}gem\PYGZus{}network} \PYG{k+kn}{import} \PYG{n}{make\PYGZus{}gem\PYGZus{}network}

\PYG{n}{pair\PYGZus{}growth}\PYG{p}{,}\PYG{n}{fba\PYGZus{}growth}\PYG{p}{,}\PYG{n}{metadata} \PYG{o}{=} \PYG{n}{get\PYGZus{}pairwise\PYGZus{}growth}\PYG{p}{(}\PYG{n}{model\PYGZus{}list}\PYG{p}{,}\PYG{n}{media\PYGZus{}pth}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This function requires the path to a file containing the paths to each genome\sphinxhyphen{}scale model, as well as the path to a media file. Media files
can be found in the \sphinxcode{\sphinxupquote{translate\_agora\_media}} directory, and updated by running the script \sphinxcode{\sphinxupquote{get\_agora\_media.py}}. Media needs to have a column containing
metabolite IDs matching those found in the GSMs, and a column containing the flux bounds for the media (both column names can be set by the user).

\sphinxAtStartPar
See {\hyperref[\detokenize{network_build:make_gem_network.get_pairwise_growth}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{make\_gem\_network.get\_pairwise\_growth()}}}}} for a full list of the options available. If the experiments as created above
are passed, then the function skips pairwise growth experiments for any pair that does not co\sphinxhyphen{}occur in the dataset.

\sphinxAtStartPar
The result is a set of simulated pairwise growth experiment results, with \sphinxcode{\sphinxupquote{pair\_growth{[}i,j{]}}} being the growth of \sphinxcode{\sphinxupquote{i}} when paired with \sphinxcode{\sphinxupquote{j}}. To create an interaction network, we can use these results in a few ways.
The simplest is to use the log\sphinxhyphen{}ratio of growth alone with growth in the pair as the Lotka\sphinxhyphen{}Volterra parameter for the partners influence on growth.


\subsection{Computing Friendliness Scores and Assessing Predictive Power}
\label{\detokenize{usage:computing-friendliness-scores-and-assessing-predictive-power}}
\sphinxAtStartPar
To compute friendliness scores for each sample on a node(s) of interest use {\hyperref[\detokenize{scoring:score_net.network_friendliness}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{score\_net.network\_friendliness()}}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{score\PYGZus{}net} \PYG{k+kn}{import} \PYG{n}{network\PYGZus{}friendliness}

\PYG{n}{friendliness} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{k}{for} \PYG{n}{target\PYGZus{}node} \PYG{o+ow}{in} \PYG{n}{nodes\PYGZus{}of\PYGZus{}interest}\PYG{p}{:}
    \PYG{n}{friendliness}\PYG{p}{[}\PYG{n}{target\PYGZus{}node}\PYG{p}{]} \PYG{o}{=} \PYG{n}{network\PYGZus{}friendliness}\PYG{p}{(}\PYG{n}{experiment}\PYG{p}{,}\PYG{n}{full\PYGZus{}interaction\PYGZus{}network}\PYG{p}{,}\PYG{n}{target\PYGZus{}node}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The return value is a pandas dataframe that can be saved as a .csv file.

\sphinxAtStartPar
To assess the predictive power of the method (for friendliness on a single \sphinxcode{\sphinxupquote{target\_node}} in \sphinxcode{\sphinxupquote{nodes\_of\_interest}}) use py:func:\sphinxtitleref{score\_net.score\_net}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{score\PYGZus{}net} \PYG{k+kn}{import} \PYG{n}{score\PYGZus{}net}

\PYG{n}{friendliness}\PYG{p}{,}\PYG{n}{predictive\PYGZus{}power} \PYG{o}{=} \PYG{n}{score\PYGZus{}net}\PYG{p}{(}\PYG{n}{experiment}\PYG{p}{,}\PYG{n}{full\PYGZus{}interaction\PYGZus{}network}\PYG{p}{,}\PYG{n}{target\PYGZus{}node}\PYG{p}{,}\PYG{n}{scoretype}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{predictive\_power}} is a dictionary of predictive power metrics, which depend on if the scoring is binary (in which case the ROC is used) or continuous (in which case correlation is used).


\subsection{Plotting the Results}
\label{\detokenize{usage:plotting-the-results}}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
I will probably add some functions to make plotting the results convenient.
\end{sphinxadmonition}


\subsection{Sensitivity to Parameters}
\label{\detokenize{usage:sensitivity-to-parameters}}
\sphinxAtStartPar
We also provide functionality to assess the sensitivity of the predictions to two types of perturbations.

\sphinxAtStartPar
The first is sensitivity to community composition, which we test using simulated knock\sphinxhyphen{}outs (i.e. computing friendliness scores with nodes removed).

\sphinxAtStartPar
The second is sensitivity to the interaction parameter values. We test this using a dynamical system for \(\frac{\partial x_i}{\partial a_{ij}}\). See {\hyperref[\detokenize{sensit::doc}]{\sphinxcrossref{\DUrole{doc}{Functions for Sensitivity Testing}}}}.

\sphinxstepscope


\chapter{Function for Formatting OTU tables}
\label{\detokenize{format:function-for-formatting-otu-tables}}\label{\detokenize{format::doc}}\index{format\_data() (in module format\_data)@\spxentry{format\_data()}\spxextra{in module format\_data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{format:format_data.format_data}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{format\_data.}}\sphinxbfcode{\sphinxupquote{format\_data}}}{\emph{\DUrole{n}{otu\_table}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Formats a dataset (starting with OTU table) into the form \sphinxcode{\sphinxupquote{dict\{samplename:(score,dict\{nodename:relative abundance\})\}}}. Will also filter out OTUs by ID or name, so that OTUs left out of an interaction network can be removed (e.g. OTUs with no available GSM).
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{otu\_table}} (\sphinxstyleliteralemphasis{\sphinxupquote{pandas.DataFrame}}) \textendash{} table of count or relative abundance data, index by OTU, columns corresponding to samples.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sample\_metadata}} (\sphinxstyleliteralemphasis{\sphinxupquote{pandas.DataFrame}}) \textendash{} sample metadata use in determining the known score for a sample. If only predictions are desired, this can be omitted and all scores will be set to 1. Should be a table indexed by sample name (can also be a dict).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{score\_col}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} column in sample\_metadata indicating known score. Default “Score”

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_names}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} map from OTU table index to taxa names that match names in a known master network or match names of cobra models for network building.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{included\_otus}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} list of otus to include in the data, all others will be excluded. Can be row names in otu table or corresponding value in name\_names. Default include all otus

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{scoretype}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Either \sphinxcode{\sphinxupquote{binary}} or \sphinxcode{\sphinxupquote{continuous}} or \sphinxcode{\sphinxupquote{infer}} for known scores for each sample. Default inferred from the sample metadata. \sphinxstylestrong{Will not} edit the scores to fit the given type.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Data formatted for easy use with friendlynet package (especially {\hyperref[\detokenize{scoring:score_net.score_net}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{score\_net}}}}})

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\chapter{Functions for Making Interation Networks from GEMs}
\label{\detokenize{network_build:functions-for-making-interation-networks-from-gems}}\label{\detokenize{network_build::doc}}\index{cocultures() (in module make\_gem\_network)@\spxentry{cocultures()}\spxextra{in module make\_gem\_network}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{network_build:make_gem_network.cocultures}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{make\_gem\_network.}}\sphinxbfcode{\sphinxupquote{cocultures}}}{\emph{\DUrole{n}{cobra\_models}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Computes steadyComX simulations, including setting media for models, for all pairs of models (optionally only co\sphinxhyphen{}occurring models).
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cobra\_models}} \textendash{} a dictionary of cobra models

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rows}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} list of keys to be used for 1 half of each pair

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cols}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} list of keys to be used for other half of each pair. If either or both is not provided, does allxall

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{media}} \textendash{} table including flux bound and modelSEED metabolite ID

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{target\_models}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} model/models of interest. Computes parameters for all interactions with these models. Must be in cobra\_models. Default empty list

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{IDtype}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} How the MODEL ids the metabolites. Should be a column of the media table.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{compartmenttag}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} how the MODEl tags exchanged metabolites (e.g. \_e0 for a modelSEED model)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fluxcol}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} column in media table with flux bound

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{keep\_fluxes}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If True, the new media will include the fluxes from the models previous media that do not appear in media. Default True.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mu}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} specific community growth rate

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{default\_inflow}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Default inflow of metabolites not listed in media

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{phi}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} forced metabolite leak

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rac}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Intracellular flux budget for RAC

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{experiments}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} or }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ of }}\sphinxstyleliteralemphasis{\sphinxupquote{same}}) \textendash{} (possibly list of) set of sets of nodes, each a tuple with (known score,data). The data should be a dictionary of abundances keyed by names of models (same as dict keys of models). Used to determine co\sphinxhyphen{}occurrence

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{min\_ra}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} cutoff to use for presence/abscence of a node in a sample. Default 10**\sphinxhyphen{}6

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
table of simulated co\sphinxhyphen{}culture results. Row/Columns are index so Table.loc{[}row,col{]} = growth of row in coculture with col

\sphinxlineitem{Return type}
\sphinxAtStartPar
pandas DF

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_pairwise\_growth() (in module make\_gem\_network)@\spxentry{get\_pairwise\_growth()}\spxextra{in module make\_gem\_network}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{network_build:make_gem_network.get_pairwise_growth}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{make\_gem\_network.}}\sphinxbfcode{\sphinxupquote{get\_pairwise\_growth}}}{\emph{\DUrole{n}{cobra\_model\_list}}, \emph{\DUrole{n}{media\_fl}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Creates interaction network for list of cobra models
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cobra\_model\_list}} \textendash{} path to .csv file with info on GEM location.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{media\_fl}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} path to media .csv

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{experiment}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} path .json file containing set of sets of nodes, each a tuple with (known score,data). The data should be a dictionary of abundances keyed by names of models (same as dict keys of models). Used to determine co\sphinxhyphen{}occurrence. All pairs computed if not given.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{silence\_load\_error}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If true, suppresses error output in loading models. Default True.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{IDtype}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} How the MODEL ids the metabolites. Should be a column of the media table. Default “fullName”

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{compartmenttag}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} how the MODEl tags exchanged metabolites (e.g. \_e0 for a modelSEED model). Default “\_e0”

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fluxcol}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} column in media table with flux bound. Default “fluxValue”

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{keep\_fluxes}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If True, the new media will include the fluxes from the models previous media that do not appear in media. Default True.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mu}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} specific community growth rate. Default 0.4

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{phi}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} forced metabolite leak. Default 0.1

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rac}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Intracellular flux budget for RAC. Default 100.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{min\_ra}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} cutoff to use for presence/abscence of a node in a sample. Default 10**\sphinxhyphen{}6

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
table of simulated co\sphinxhyphen{}culture results. Row/Columns are index so Table.loc{[}row,col{]} = growth of row in coculture with col as well as FBA solution for each model. Growth of each model with standard FBA. Parameters used.

\sphinxlineitem{Return type}
\sphinxAtStartPar
pandas.DataFrame, pandas.Series, dict

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_co\_occ() (in module make\_gem\_network)@\spxentry{check\_co\_occ()}\spxextra{in module make\_gem\_network}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{network_build:make_gem_network.check_co_occ}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{make\_gem\_network.}}\sphinxbfcode{\sphinxupquote{check\_co\_occ}}}{\emph{\DUrole{n}{experiment}}, \emph{\DUrole{n}{min\_ra}\DUrole{o}{=}\DUrole{default_value}{1e\sphinxhyphen{}06}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Check which nodes co\sphinxhyphen{}occurr in samples, so that we don’t need to compute an interaction between those that don’t
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{experiment}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} set of sets of nodes, as a dictionary of tuples with (known score,data) keyed by sample identifier. The data should be a dictionary of abundances keyed by node names.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{min\_ra}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} cutoff to use for presence/abscence of a node in a sample. Default 10**\sphinxhyphen{}6

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
NxN array with bool indicating if the pair co\sphinxhyphen{}occures, and list of nodes giving ordering of this array.

\sphinxlineitem{Return type}
\sphinxAtStartPar
array{[}bool{]},list{[}str{]}

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\chapter{Functions to Generate and Evaluate Predictions}
\label{\detokenize{scoring:functions-to-generate-and-evaluate-predictions}}\label{\detokenize{scoring::doc}}\index{network\_friendliness() (in module score\_net)@\spxentry{network\_friendliness()}\spxextra{in module score\_net}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{scoring:score_net.network_friendliness}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{score\_net.}}\sphinxbfcode{\sphinxupquote{network\_friendliness}}}{\emph{\DUrole{n}{experiment}}, \emph{\DUrole{n}{full\_net}}, \emph{\DUrole{n}{target\_node}}, \emph{\DUrole{n}{models}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{min\_ra}\DUrole{o}{=}\DUrole{default_value}{1e\sphinxhyphen{}06}}, \emph{\DUrole{n}{odeTrials}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This method computes the extent to which a set of sets of nodes are friendly to a particular node, using \sphinxcode{\sphinxupquote{friendlyNets}}.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{experiment}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Dictionary of samples. Each should be a dictionary of abundances keyed by node names. (Also supports dict of tuples as in {\hyperref[\detokenize{scoring:score_net.score_net}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{score\_net}}}}}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{full\_net}} (\sphinxstyleliteralemphasis{\sphinxupquote{pandas dataframe}}) \textendash{} Adjacency matrix of all interaction parameters between pairs of nodes in the entire experiment set.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{target\_node}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of node of interest. (must be in full\_net, need not be in sample \sphinxhyphen{} will be added to induced subgraph)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{models}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} list of models you wish to use for scoring. Leave as None for all 6. Options are “LV”,”InhibitLV”,”AntLV”,”Replicator”,”NodeBalance”,”Stochastic”.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{min\_ra}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} cutoff to use for presence/abscence of a node in a sample. Default 10**\sphinxhyphen{}6

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{odeTrials}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of ODE simulations in score estimation. If None, equal to number of non\sphinxhyphen{}zero taxa in a sample. Default None

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
friendliness scores for each sample and each model in models.

\sphinxlineitem{Return type}
\sphinxAtStartPar
pandas dataframe

\end{description}\end{quote}

\end{fulllineitems}

\index{score\_net() (in module score\_net)@\spxentry{score\_net()}\spxextra{in module score\_net}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{scoring:score_net.score_net}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{score\_net.}}\sphinxbfcode{\sphinxupquote{score\_net}}}{\emph{\DUrole{n}{experiment}}, \emph{\DUrole{n}{full\_net}}, \emph{\DUrole{n}{target\_node}}, \emph{\DUrole{n}{scoretype}}, \emph{\DUrole{n}{models}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{min\_ra}\DUrole{o}{=}\DUrole{default_value}{1e\sphinxhyphen{}06}}, \emph{\DUrole{n}{odeTrials}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This method computes the extent to which a set of sets of nodes are friendly to a particular node, using \sphinxcode{\sphinxupquote{friendlyNets}},
and \sphinxstylestrong{compares} this with a known effect of the community, which can be binary (good/bad) or continuous (e.g. relative abundance at a later time point) to compute predictive performance
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{experiment}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Dictionary of samples, each a tuple with (known score,data). The data should be a dictionary of abundances keyed by node names.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{full\_net}} (\sphinxstyleliteralemphasis{\sphinxupquote{pandas dataframe}}) \textendash{} Adjacency matrix of all interaction parameters between pairs of nodes in the entire experiment set.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{target\_node}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of node of interest. (must be in full\_net, need not be in sample \sphinxhyphen{} will be added to induced subgraph)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{scoretype}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Type of known score (\sphinxtitleref{b} or \sphinxtitleref{binary} for binary, \sphinxtitleref{c} or \sphinxtitleref{continuous} for continuous)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{models}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} list of models you wish to use for scoring. Leave as None for all 6. Options are “LV”,”InhibitLV”,”AntLV”,”Replicator”,”NodeBalance”,”Stochastic”.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{min\_ra}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} cutoff to use for presence/abscence of a node in a sample. Default 10**\sphinxhyphen{}6

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{odeTrials}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of ODE simulations in score estimation. If None, equal to number of non\sphinxhyphen{}zero taxa in a sample. Default None

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
friendliness scores, predictive performance dictionary. If binary scoring, predictive performance is AUROC, ROC curves, and the mean AUROC.If continuous scoring, this is pearson correlation between friendliness score and known score, pearson p valule, kendall correlation, and kendall p value,spearman correlation, spearman p value. Correlation values are rescaled to {[}0,1{]} (from {[}\sphinxhyphen{}1,1{]}) to better match AUCROC scores.

\sphinxlineitem{Return type}
\sphinxAtStartPar
tuple of pandas dataframe, \{dict, dict, float\} OR tuple of pandas dataframe, \{dict,dict,dict,dict,dict,dict\}

\end{description}\end{quote}

\end{fulllineitems}

\index{score\_light() (in module score\_net)@\spxentry{score\_light()}\spxextra{in module score\_net}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{scoring:score_net.score_light}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{score\_net.}}\sphinxbfcode{\sphinxupquote{score\_light}}}{\emph{\DUrole{n}{experiment}}, \emph{\DUrole{n}{full\_net}}, \emph{\DUrole{n}{target\_node}}, \emph{\DUrole{n}{scoretype}}, \emph{\DUrole{n}{score\_model}}, \emph{\DUrole{n}{self\_inhibit}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{min\_ra}\DUrole{o}{=}\DUrole{default_value}{1e\sphinxhyphen{}06}}, \emph{\DUrole{n}{odeTrials}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{lvshift}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{cntbu}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{keepscores}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{KO}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This method computes the extent to which a set of sets of nodes are friendly to a particular node, using \sphinxcode{\sphinxupquote{friendlyNets}},
and compares this with a known effect of the community, which can be binary (good/bad) or continuous (e.g. relative abundance at a later time point). This version
only computes a score for a single type of model, but offers more parameter flexibility, including Shift and Self Inhibition in the {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.lotka_volterra_system}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Lotka\sphinxhyphen{}Volterra system}}}}}
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{experiment}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} set of sets of nodes, each a tuple with (known score,data). The data should be a dictionary of abundances keyed by node names.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{full\_net}} (\sphinxstyleliteralemphasis{\sphinxupquote{pandas dataframe}}) \textendash{} Adjacency matrix of all interaction parameters between pairs of nodes in the entire experiment set.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{target\_node}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of node of interest. (must be in full\_net, need not be in sample \sphinxhyphen{} will be added to induced subgraph)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{scoretype}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Type of known score (\sphinxtitleref{b} for binary, \sphinxtitleref{c} for continuous)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{score\_model}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Dynamical model to use for scoring. Choices LV, AntLV, InhibitLV, Replicator, NodeBalance, Stochastic, Composite, as detailed in {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.score_node}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{score\_node}}}}}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{self\_inhibit}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} extent to which the model should include self inhibition \sphinxhyphen{} self interaction terms (\(A_{ii}\)) will be set to negative \sphinxcode{\sphinxupquote{self\_inhibit}}. Default 0

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{min\_ra}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} cutoff to use for presence/abscence of a node in a sample. Default 10**\sphinxhyphen{}6

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{odeTrials}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of ODE simulations in score estimation. If None, equal to number of non\sphinxhyphen{}zero taxa in a sample. Default None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{lvshift}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Uniform (subtracted) modifier to interactions. Lotka\sphinxhyphen{}Volterra parameters will be {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.Adjacency}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Adjacency}}}}} \sphinxhyphen{} \sphinxcode{\sphinxupquote{shift}}. Default 0

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cntbu}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Whether or not to count the number of blow\sphinxhyphen{}ups in the simulations. Default False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{keepscores}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Wether or not to return the friendliness scores. If False, only returns the predictive performance.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{KO}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Knockout nodes to remove from data

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
evaluation of prediction, as AUCROC or (kendall, spearman), optionally count of ODE blowups, and optionally sample ordering, friendliness scores (in that order)

\sphinxlineitem{Return type}
\sphinxAtStartPar
tuple float (or float,float), optional float, optional list{[}str{]}, optional array{[}float{]}

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\chapter{Functions for Sensitivity Testing}
\label{\detokenize{sensit:functions-for-sensitivity-testing}}\label{\detokenize{sensit::doc}}

\section{Functions for Lotka\sphinxhyphen{}Volterra Interaction Parameter Sensitivity Testing}
\label{\detokenize{sensit:functions-for-lotka-volterra-interaction-parameter-sensitivity-testing}}\index{get\_all\_sensitivity() (in module sensitivity)@\spxentry{get\_all\_sensitivity()}\spxextra{in module sensitivity}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sensit:sensitivity.get_all_sensitivity}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{sensitivity.}}\sphinxbfcode{\sphinxupquote{get\_all\_sensitivity}}}{\emph{\DUrole{n}{target\_node}}, \emph{\DUrole{n}{fnet}}, \emph{\DUrole{n}{entries}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}all\textquotesingle{}}}, \emph{\DUrole{n}{shift}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{self\_inhibit}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{numtrials}\DUrole{o}{=}\DUrole{default_value}{100}}, \emph{\DUrole{n}{nj}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{mxTime}\DUrole{o}{=}\DUrole{default_value}{1000}}, \emph{\DUrole{n}{wpts}\DUrole{o}{=}\DUrole{default_value}{40}}, \emph{\DUrole{n}{base\_we}\DUrole{o}{=}\DUrole{default_value}{1.5}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Compute sensitivity of a node to interaction parameters, and average over simulations. Computes weighted average, using \sphinxstyleemphasis{final} \sphinxcode{\sphinxupquote{wpts}} timepoints with increasing weight. Weight s is computed as \(b^s\) where \(b\) is \sphinxcode{\sphinxupquote{base\_we}} and then weights are rescaled to sum to 1.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{target\_node}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} name node of interest (nodes are usually named with str, but can be named with other objects, most commonly int equal to node index.)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fnet}} ({\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{friendlyNet}}}}}) \textendash{} network of interactions for the model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{entries}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Which interaction parameters to test sensitivity to (names). If ‘all’, tests for every parameter. Otherwise, should be a list of tuples of names (source,target). Default ‘all’

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shift}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Uniform (subtracted) modifier to interactions. Lotka\sphinxhyphen{}Volterra parameters will be {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.Adjacency}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Adjacency}}}}} \sphinxhyphen{} \sphinxcode{\sphinxupquote{shift}}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{self\_inhibit}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} extent to which the model should include self inhibition \sphinxhyphen{} self interaction terms (\(a_{ii}\)) will be set to \sphinxhyphen{}\sphinxcode{\sphinxupquote{self\_inhibit}}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{numtrials}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of simulations to average over

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nj}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of trials to run in parallel (using joblib)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mxTime}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} time length of simulations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{wpts}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of time\sphinxhyphen{}points in each simulation to average over (will be final time\sphinxhyphen{}points). Default 40

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{base\_we}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} base for weights of time\sphinxhyphen{}averaging \sphinxhyphen{} should be \(>1\) for increasing weight, equal to 1 for uniform weight on last \sphinxcode{\sphinxupquote{wpt}} time\sphinxhyphen{}points. Default 1.5

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Average value of \(\partial x_i/\partial a_{kl}\) averaged first over time points in each simulation and next over simulations. If \sphinxcode{\sphinxupquote{pars}} == ‘all’, returns NxN array indexed by {[}source,target{]}. Otherwise, returns 1d array corresponding to ‘pars’

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_all\_sensitivity\_single\_trajectory() (in module sensitivity)@\spxentry{get\_all\_sensitivity\_single\_trajectory()}\spxextra{in module sensitivity}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sensit:sensitivity.get_all_sensitivity_single_trajectory}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{sensitivity.}}\sphinxbfcode{\sphinxupquote{get\_all\_sensitivity\_single\_trajectory}}}{\emph{\DUrole{n}{fnet}}, \emph{\DUrole{n}{i}}, \emph{\DUrole{n}{shift}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{self\_inhibit}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{weights}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{mxTime}\DUrole{o}{=}\DUrole{default_value}{1000}}, \emph{\DUrole{n}{pars}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}all\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Compute sensitivity of node i to every interaction parameter. To do this, we need to solve an ODE that arises from the chain rule. Because we can reuse the solution to the lotka\sphinxhyphen{}volerra
system, we don’t want to repeatedly call get\_sensitivity on a each parameter.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fnet}} ({\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{friendlyNet}}}}}) \textendash{} network of interactions for the model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{i}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} index of node of interest

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shift}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Uniform (subtracted) modifier to interactions. Lotka\sphinxhyphen{}Volterra parameters will be {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.Adjacency}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Adjacency}}}}} \sphinxhyphen{} \sphinxcode{\sphinxupquote{shift}}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{self\_inhibit}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} extent to which the model should include self inhibition \sphinxhyphen{} self interaction terms (\(a_{ii}\)) will be set to \sphinxhyphen{}\sphinxcode{\sphinxupquote{self\_inhibit}}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{weights}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} weights for time\sphinxhyphen{}points of the ODE solution. This allows us to weight the later timepoints (closer to equilibrium) higher, or not, with some granularity. Default unweighted.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mxTime}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} time length of simulations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pars}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Which interaction parameters to test sensitivity to. If ‘all’, tests for every parameter. Otherwise, should be a list of tuples of indices (source,target). Default ‘all’

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
(possibly weighted) average value of \(\partial x_i/\partial a_{kl}\) over time points in simulation for each. If \sphinxcode{\sphinxupquote{pars}} == ‘all’, returns NxN array indexed by {[}source,target{]}. Otherwise, returns 1d array corresponding to ‘pars’

\sphinxlineitem{Return type}
\sphinxAtStartPar
array{[}float{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_sensitivity\_single\_trajectory() (in module sensitivity)@\spxentry{get\_sensitivity\_single\_trajectory()}\spxextra{in module sensitivity}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sensit:sensitivity.get_sensitivity_single_trajectory}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{sensitivity.}}\sphinxbfcode{\sphinxupquote{get\_sensitivity\_single\_trajectory}}}{\emph{\DUrole{n}{fnet}}, \emph{\DUrole{n}{i}}, \emph{\DUrole{n}{k}}, \emph{\DUrole{n}{l}}, \emph{\DUrole{n}{soln}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{shift}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{self\_inhibit}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{weights}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{mxTime}\DUrole{o}{=}\DUrole{default_value}{1000}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Compute sensitivity of node i to parameter \(a_{kl}\). To do this, we need to solve an ODE that arises from the chain rule.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fnet}} ({\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{friendlyNet}}}}}) \textendash{} network of interactions for the model

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{i}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} index of node of interest

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} source node of interaction of interest

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{l}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} target node of interaction of interest

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{soln}} (\sphinxstyleliteralemphasis{\sphinxupquote{scipy.integrate.solve\_ivp object}}) \textendash{} solution to lotka\sphinxhyphen{}volterra system \sphinxstyleemphasis{must use same shift and self\_inhibit parameters}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shift}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Uniform (subtracted) modifier to interactions. Lotka\sphinxhyphen{}Volterra parameters will be {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.Adjacency}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Adjacency}}}}} \sphinxhyphen{} \sphinxcode{\sphinxupquote{shift}}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{self\_inhibit}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} extent to which the model should include self inhibition \sphinxhyphen{} self interaction terms (\(a_{ii}\)) will be set to \sphinxhyphen{}\sphinxcode{\sphinxupquote{self\_inhibit}}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{weights}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} weights for time\sphinxhyphen{}points of the ODE solution. This allows us to weight the later timepoints (closer to equilibrium) higher, or not, with some granularity. Default unweighted.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mxTime}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} time length of simulations

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
(possibly weighted) average value of \(\partial x_i/\partial a_{kl}\) over time points in simulation.

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{sense\_kl() (in module sensitivity)@\spxentry{sense\_kl()}\spxextra{in module sensitivity}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sensit:sensitivity.sense_kl}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{sensitivity.}}\sphinxbfcode{\sphinxupquote{sense\_kl}}}{\emph{\DUrole{n}{t}}, \emph{\DUrole{n}{ps}}, \emph{\DUrole{n}{x}}, \emph{\DUrole{n}{k}}, \emph{\DUrole{n}{l}}, \emph{\DUrole{n}{net}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Dynamical system for senstivity \(\partial x_i/\partial a_{kl}\) for a Lotka\sphinxhyphen{}Volterra interaction parameter.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{t}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} time in simulation

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ps}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} state in simulatoin

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{function}}) \textendash{} Lotka\sphinxhyphen{}Volterra solution (dense output of scipy.integrate.solve\_ivp)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{k}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} index of source of interaction

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{l}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} index of target of interaction

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{net}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} adjacency matrix for Lotka\sphinxhyphen{}Volterra system

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
right\sphinxhyphen{}hand side of dynamical system

\sphinxlineitem{Return type}
\sphinxAtStartPar
array{[}float{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{compute\_j() (in module sensitivity)@\spxentry{compute\_j()}\spxextra{in module sensitivity}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sensit:sensitivity.compute_j}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{sensitivity.}}\sphinxbfcode{\sphinxupquote{compute\_j}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{net}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Helper function to compute a term in the dynamical system defined by {\hyperref[\detokenize{sensit:sensitivity.sense_kl}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{sense\_kl}}}}}.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Lotka\sphinxhyphen{}Volterra state at time t

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{net}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} adjacency matrix for Lotka\sphinxhyphen{}Volterra system

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
term in RHS

\sphinxlineitem{Return type}
\sphinxAtStartPar
array{[}float{]}

\end{description}\end{quote}

\end{fulllineitems}


\sphinxstepscope


\chapter{The FriendlyNet class}
\label{\detokenize{friendlynets:the-friendlynet-class}}\label{\detokenize{friendlynets::doc}}
\sphinxAtStartPar
This is the core class of the method, a network class built from an adjacency matrix that contains methods for measuring friendliness to the nodes.
\index{friendlyNet (class in friendlyNet)@\spxentry{friendlyNet}\spxextra{class in friendlyNet}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{friendlyNet.}}\sphinxbfcode{\sphinxupquote{friendlyNet}}}{\emph{\DUrole{n}{adj}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Network class designed for testing how positive a directed network is for a node. Provides several ways to score the network’s friendliness for a given node. By friendliness,
we mean some measure of how much the network promotes/inhibits a node based on a choice of interaction model represented by the graph (e.g. Lotka\sphinxhyphen{}Volterra or Diffusion).
Rescales the adjacency matrix so that all weights are in \([0,1]\)
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{adj}} (\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{N}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{N}}\sphinxstyleliteralemphasis{\sphinxupquote{) }}\sphinxstyleliteralemphasis{\sphinxupquote{array}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Adjacency matrix of the graph.

\end{description}\end{quote}
\index{Adjacency (friendlyNet.friendlyNet attribute)@\spxentry{Adjacency}\spxextra{friendlyNet.friendlyNet attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.Adjacency}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{Adjacency}}}
\pysigstopsignatures
\sphinxAtStartPar
Network adjacency matrix, rescaled so that all weights are in \([0,1]\)

\end{fulllineitems}

\index{NodeNames (friendlyNet.friendlyNet attribute)@\spxentry{NodeNames}\spxextra{friendlyNet.friendlyNet attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.NodeNames}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{NodeNames}}}
\pysigstopsignatures
\sphinxAtStartPar
List of names of the nodes, corresponding to ordering of adjacency matrix

\end{fulllineitems}

\index{InDegree (friendlyNet.friendlyNet attribute)@\spxentry{InDegree}\spxextra{friendlyNet.friendlyNet attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.InDegree}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{InDegree}}}
\pysigstopsignatures
\sphinxAtStartPar
Total weight of edges into each node

\end{fulllineitems}

\index{OutDegree (friendlyNet.friendlyNet attribute)@\spxentry{OutDegree}\spxextra{friendlyNet.friendlyNet attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.OutDegree}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{OutDegree}}}
\pysigstopsignatures
\sphinxAtStartPar
Total weight of edges out of each node

\end{fulllineitems}

\index{NodeScores (friendlyNet.friendlyNet attribute)@\spxentry{NodeScores}\spxextra{friendlyNet.friendlyNet attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.NodeScores}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{NodeScores}}}
\pysigstopsignatures
\sphinxAtStartPar
Pandas DataFrame of friendliness scores for each node for a set of chosen dynamical models.

\end{fulllineitems}

\index{EdgeList (friendlyNet.friendlyNet attribute)@\spxentry{EdgeList}\spxextra{friendlyNet.friendlyNet attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.EdgeList}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{EdgeList}}}
\pysigstopsignatures
\sphinxAtStartPar
Pandas DataFrame of edges (with weights) for the network that can be easily saved and loaded into cytoscape. See {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.make_edge_list}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{make\_edge\_list}}}}}

\end{fulllineitems}

\index{make\_edge\_list() (friendlyNet.friendlyNet method)@\spxentry{make\_edge\_list()}\spxextra{friendlyNet.friendlyNet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.make_edge_list}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{make\_edge\_list}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Create a list of edges with columns:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Source

\item {} 
\sphinxAtStartPar
Target

\item {} 
\sphinxAtStartPar
Weight

\item {} 
\sphinxAtStartPar
ABS\_Weight (absolute value)

\item {} 
\sphinxAtStartPar
Sign\_Weight

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Modifies}
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.EdgeList}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{EdgeList}}}}}

\end{itemize}
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
None

\end{description}\end{quote}

\end{fulllineitems}

\index{lotka\_volterra\_system() (friendlyNet.friendlyNet method)@\spxentry{lotka\_volterra\_system()}\spxextra{friendlyNet.friendlyNet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.lotka_volterra_system}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{lotka\_volterra\_system}}}{\emph{\DUrole{n}{t}}, \emph{\DUrole{n}{s}}, \emph{\DUrole{n}{shift}}, \emph{\DUrole{n}{self\_inhibit}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Right\sphinxhyphen{}Hand side of generalized Lotka\sphinxhyphen{}Volterra dynamical system, using {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.Adjacency}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Adjacency}}}}} for interactions:
\begin{equation*}
\begin{split}\dot{x}_i = x_i(1+\sum_{j=1}^N a_{ij} x_j)\end{split}
\end{equation*}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{t}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} time in simulation

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{s}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} State of simulation (species abundance)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shift}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Uniform (subtracted) modifier to interactions. Lotka\sphinxhyphen{}Volterra parameters will be {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.Adjacency}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Adjacency}}}}} \sphinxhyphen{} \sphinxcode{\sphinxupquote{shift}}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{self\_inhibit}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} extent to which the model should include self inhibition \sphinxhyphen{} self interaction terms (\(a_{ii}\)) will be set to \sphinxhyphen{}\sphinxcode{\sphinxupquote{self\_inhibit}}

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
value of vector field at t,s

\sphinxlineitem{Return type}
\sphinxAtStartPar
array{[}float{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{solve\_lotka\_volterra() (friendlyNet.friendlyNet method)@\spxentry{solve\_lotka\_volterra()}\spxextra{friendlyNet.friendlyNet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.solve_lotka_volterra}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{solve\_lotka\_volterra}}}{\emph{\DUrole{n}{s0}}, \emph{\DUrole{n}{T}}, \emph{\DUrole{n}{shift}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{bup}\DUrole{o}{=}\DUrole{default_value}{1000}}, \emph{\DUrole{n}{self\_inhibit}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Solves the generalized Lotka\sphinxhyphen{}Volterra dynamical system, using {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.Adjacency}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Adjacency}}}}} for interactions
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{s0}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Inital state of simulation (species abundance)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{T}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Simulation length

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shift}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Uniform (subtracted) modifier to interactions. Lotka\sphinxhyphen{}Volterra parameters will be {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.Adjacency}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Adjacency}}}}} \sphinxhyphen{} \sphinxcode{\sphinxupquote{shift}}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bup}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} maximum abundance to allow in simulation. If any state variable reaches this value, it is assumed that the simulation has exhibited finite\sphinxhyphen{}time blowup and the simulation is stopped.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{self\_inhibit}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} extent to which the model should include self inhibition \sphinxhyphen{} self interaction terms (\(A_{ii}\)) will be set to negative \sphinxcode{\sphinxupquote{self\_inhibit}}

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Solution to the Lotka\sphinxhyphen{}Volterra dynamics

\sphinxlineitem{Return type}
\sphinxAtStartPar
scipy.integrate.solve\_ivp solution

\end{description}\end{quote}

\end{fulllineitems}

\index{lotka\_volterra\_score\_single() (friendlyNet.friendlyNet method)@\spxentry{lotka\_volterra\_score\_single()}\spxextra{friendlyNet.friendlyNet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.lotka_volterra_score_single}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{lotka\_volterra\_score\_single}}}{\emph{\DUrole{n}{node}}, \emph{\DUrole{n}{mxTime}\DUrole{o}{=}\DUrole{default_value}{100}}, \emph{\DUrole{n}{shift}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{self\_inhibit}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Uses the Lotka\sphinxhyphen{}Volterra dynamical system to determine the network’s friendliness to a particular node. Solves the system using {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.solve_lotka_volterra}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{solve\_lotka\_volterra}}}}}.
Solves the Lotka\sphinxhyphen{}Volterra system with random initial conditions and computes a score. The score is based on final relative abundance, but for finer scoring we also account for time to extinction
and time to domination (e.g. relative abundance near 1). The score is computed as

\sphinxAtStartPar
where \(T_e\) is the proportion of the time internal that the species is \sphinxstyleemphasis{not} extinct, \(T_d\) is the proportion of the time interval that the species \sphinxstyleemphasis{is} dominant, and \(r\) is the final relative abundance of the species.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} name or index of node

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mxTime}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} time length of simulations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shift}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Uniform (subtracted) modifier to interactions. Lotka\sphinxhyphen{}Volterra parameters will be {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.Adjacency}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Adjacency}}}}} \sphinxhyphen{} \sphinxcode{\sphinxupquote{shift}}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{self\_inhibit}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} extent to which the model should include self inhibition \sphinxhyphen{} self interaction terms (\(A_{ii}\)) will be set to negative \sphinxcode{\sphinxupquote{self\_inhibit}}

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Friendliness of the network to the node, according to the single Lotka\sphinxhyphen{}Volterra simulation, and the status of the ODE solution

\sphinxlineitem{Return type}
\sphinxAtStartPar
tuple{[}float,str{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{lotka\_volterra\_score() (friendlyNet.friendlyNet method)@\spxentry{lotka\_volterra\_score()}\spxextra{friendlyNet.friendlyNet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.lotka_volterra_score}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{lotka\_volterra\_score}}}{\emph{\DUrole{n}{node}}, \emph{\DUrole{n}{mxTime}\DUrole{o}{=}\DUrole{default_value}{100}}, \emph{\DUrole{n}{numtrials}\DUrole{o}{=}\DUrole{default_value}{1000}}, \emph{\DUrole{n}{nj}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{}1}}, \emph{\DUrole{n}{shift}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{self\_inhibit}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{cntbu}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Provides a score using repeated trials of the Lotka\sphinxhyphen{}Volterra system. Scores using {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.lotka_volterra_score_single}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{lotka\_volterra\_score\_single}}}}}
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} name or index of node

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mxTime}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} time length of simulations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{numtrials}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of ODE solutions and corresponding scores to compute

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nj}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of parrallel simulations to run concurrently (uses joblib)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shift}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Uniform (subtracted) modifier to interactions. Lotka\sphinxhyphen{}Volterra parameters will be {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.Adjacency}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Adjacency}}}}} \sphinxhyphen{} \sphinxcode{\sphinxupquote{shift}}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{self\_inhibit}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} extent to which the model should include self inhibition \sphinxhyphen{} self interaction terms (\(A_{ii}\)) will be set to negative \sphinxcode{\sphinxupquote{self\_inhibit}}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cntbu}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Whether or not to count the number of blow\sphinxhyphen{}ups in the simulations

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
score from {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.lotka_volterra_score_single}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{lotka\_volterra\_score\_single}}}}} averaged over all trials, optinoally number of blowups in simulation

\sphinxlineitem{Return type}
\sphinxAtStartPar
float,int

\end{description}\end{quote}

\end{fulllineitems}

\index{replicator\_system() (friendlyNet.friendlyNet method)@\spxentry{replicator\_system()}\spxextra{friendlyNet.friendlyNet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.replicator_system}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{replicator\_system}}}{\emph{\DUrole{n}{t}}, \emph{\DUrole{n}{s}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Right\sphinxhyphen{}Hand side of replicator dynamical system, using {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.Adjacency}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Adjacency}}}}} for interactions:
\begin{equation*}
\begin{split}\dot{x}_i = x_i(\sum_{j=1}^N a_{ij} x_j - x^TAx)\end{split}
\end{equation*}\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{t}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} time in simulation

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{s}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} State of simulation (species abundance)

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
value of vector field at t,s

\sphinxlineitem{Return type}
\sphinxAtStartPar
array{[}float{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{solve\_replicator() (friendlyNet.friendlyNet method)@\spxentry{solve\_replicator()}\spxextra{friendlyNet.friendlyNet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.solve_replicator}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{solve\_replicator}}}{\emph{\DUrole{n}{s0}}, \emph{\DUrole{n}{T}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Solves the replicator dynamical system, using {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.Adjacency}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Adjacency}}}}} for interactions
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{s0}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Inital state of simulation (species abundance)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{T}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Simulation length

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Solution to the replicator dynamics

\sphinxlineitem{Return type}
\sphinxAtStartPar
scipy.integrate.solve\_ivp solution

\end{description}\end{quote}

\end{fulllineitems}

\index{replicator\_score\_single() (friendlyNet.friendlyNet method)@\spxentry{replicator\_score\_single()}\spxextra{friendlyNet.friendlyNet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.replicator_score_single}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{replicator\_score\_single}}}{\emph{\DUrole{n}{node}}, \emph{\DUrole{n}{mxTime}\DUrole{o}{=}\DUrole{default_value}{100}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Uses the replicator dynamical system to determine the network’s friendliness to a particular node. Solves the system using {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.solve_replicator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{solve\_replicator}}}}}.
Solves the replicator system with random initial conditions and computes a score. The score is based on final relative abundance, but for finer scoring we also account for time to extinction
and time to domination (e.g. relative abundance near 1). The score is computed as

\sphinxAtStartPar
where \(T_e\) is the proportion of the time internal that the species is \sphinxstyleemphasis{not} extinct, \(T_d\) is the proportion of the time interval that the species \sphinxstyleemphasis{is} dominant, and \(r\) is the final relative abundance of the species.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} name or index of node

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mxTime}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} time length of simulations

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Friendliness of the network to the node, according to the single replicator simulation, and the status of the ODE solution

\sphinxlineitem{Return type}
\sphinxAtStartPar
tuple{[}float,str{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{replicator\_score() (friendlyNet.friendlyNet method)@\spxentry{replicator\_score()}\spxextra{friendlyNet.friendlyNet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.replicator_score}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{replicator\_score}}}{\emph{\DUrole{n}{node}}, \emph{\DUrole{n}{mxTime}\DUrole{o}{=}\DUrole{default_value}{100}}, \emph{\DUrole{n}{numtrials}\DUrole{o}{=}\DUrole{default_value}{1000}}, \emph{\DUrole{n}{nj}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{}1}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Provides a score using repeated trials of the replicator system. Scores using {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.replicator_score_single}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{replicator\_score\_single}}}}}
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} name or index of node

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mxTime}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} time length of simulations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{numtrials}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of ODE solutions and corresponding scores to compute

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nj}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of parrallel simulations to run concurrently (uses joblib)

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
score from {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.lotka_volterra_score_single}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{lotka\_volterra\_score\_single}}}}} averaged over all trials

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{node\_balanced\_score() (friendlyNet.friendlyNet method)@\spxentry{node\_balanced\_score()}\spxextra{friendlyNet.friendlyNet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.node_balanced_score}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{node\_balanced\_score}}}{\emph{\DUrole{n}{node}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Provides a score based on the linear system

\sphinxAtStartPar
where \(L= A^T-D\) is the graph laplance matrix for the graph after weights have been rescaled to the interval \([0,1]\).
This dynamical system arises from the notion of node\sphinxhyphen{}balancing the graph. Because this is linear, we can use the dominant eigenvector of the
laplacian to compute equilibrium.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} name or index of node

\sphinxlineitem{Returns}
\sphinxAtStartPar
Value of node in dominant eigenvector (i.e. equilibrium solution)

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{node\_balanced\_system() (friendlyNet.friendlyNet method)@\spxentry{node\_balanced\_system()}\spxextra{friendlyNet.friendlyNet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.node_balanced_system}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{node\_balanced\_system}}}{\emph{\DUrole{n}{T}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Function to provide a simulation for the node\sphinxhyphen{}balancing linear system

\sphinxAtStartPar
where \(L= A^T-D\) is the graph laplance matrix for the graph after weights have been rescaled to the interval \([0,1]\).
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{T}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} End time of simulation

\sphinxlineitem{Returns}
\sphinxAtStartPar
Solution to the node balance dynamics

\sphinxlineitem{Return type}
\sphinxAtStartPar
scipy.integrate.solve\_ivp solution

\end{description}\end{quote}

\end{fulllineitems}

\index{stochastic\_score() (friendlyNet.friendlyNet method)@\spxentry{stochastic\_score()}\spxextra{friendlyNet.friendlyNet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.stochastic_score}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{stochastic\_score}}}{\emph{\DUrole{n}{node}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Provides a score based on the linear system that simulates concurrent random walks (or, equivalently, diffusion) on the graph.
We rescale the adjacency matrix to build a stochastic matrix that represents the transition probabilities in a random walk on the graph.
The eigenvectors of this matrix provide a stationary distribution for the cuncurrent random walks.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} name or index of node

\sphinxlineitem{Returns}
\sphinxAtStartPar
Value of node in stationary distribution

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{score\_node() (friendlyNet.friendlyNet method)@\spxentry{score\_node()}\spxextra{friendlyNet.friendlyNet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.score_node}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{score\_node}}}{\emph{\DUrole{n}{node}}, \emph{\DUrole{n}{scores}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{odeTrials}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Function to score a node using a set of scores. Choose any list of the following:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{LV} The {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.lotka_volterra_system}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Lotka\sphinxhyphen{}Volterra system}}}}}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{InhibitLV} {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.lotka_volterra_system}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Lotka\sphinxhyphen{}Volterra system}}}}} with self inhibition = 1

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{AntLV} The {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.lotka_volterra_system}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Lotka\sphinxhyphen{}Volterra system}}}}} with all interactions shifted by \sphinxhyphen{}1 to make them antagonistic.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Replicator} The {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.replicator_system}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{replicator equation dynamics}}}}}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{NodeBalance} The linear {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.node_balanced_score}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{node balancing dynamical system}}}}}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Stochastic} The linear {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.stochastic_score}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{random walk dynamical system}}}}}

\end{itemize}

\sphinxAtStartPar
A composite score will be included, which is simply the mean of each score included.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name or index of node

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{scores}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} list of score types you wish to use. Leave as None for all 6.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{odeTrials}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of simulations of the Lotka\sphinxhyphen{}Volterra and replicator dynamics to use to estimate the score. Leave as None for number of trials equal to number of nodes in the network.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Dictionary of scores keyed by score type.

\sphinxlineitem{Trype}
\sphinxAtStartPar
dict{[}str,float{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{score\_all\_nodes() (friendlyNet.friendlyNet method)@\spxentry{score\_all\_nodes()}\spxextra{friendlyNet.friendlyNet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{friendlynets:friendlyNet.friendlyNet.score_all_nodes}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{score\_all\_nodes}}}{\emph{\DUrole{n}{scores}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{odeTrials}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Function to score all nodes using a set of scores. Choose any list of the following:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{LV} The {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.lotka_volterra_system}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Lotka\sphinxhyphen{}Volterra system}}}}}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{InhibitLV} {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.lotka_volterra_system}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Lotka\sphinxhyphen{}Volterra system}}}}} with self inhibition = 1

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{AntLV} The {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.lotka_volterra_system}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Lotka\sphinxhyphen{}Volterra system}}}}} with all interactions shifted by \sphinxhyphen{}1 to make them antagonistic.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Replicator} The {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.replicator_system}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{replicator equation dynamics}}}}}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{NodeBalance} The linear {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.node_balanced_score}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{node balancing dynamical system}}}}}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Stochastic} The linear {\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.stochastic_score}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{random walk dynamical system}}}}}

\end{itemize}

\sphinxAtStartPar
A composite score will be included, which is simply the mean of each score included.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{scores}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} list of score types you wish to use. Leave as None for all 6.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{odeTrials}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of simulations of the Lotka\sphinxhyphen{}Volterra and replicator dynamics to use to estimate the score. Leave as None for number of trials equal to number of nodes in the network.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Table of scores for each node and score type chosen

\sphinxlineitem{Trype}
\sphinxAtStartPar
pandas dataframe

\end{description}\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{Modifies}
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{friendlynets:friendlyNet.friendlyNet.NodeScores}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{NodeScores}}}}}

\end{itemize}

\end{fulllineitems}


\end{fulllineitems}


\begin{sphinxthebibliography}{KSC22}
\bibitem[KSC22]{index:id3}
\sphinxAtStartPar
Minsuk Kim, Jaeyun Sung, and Nicholas Chia. Resource\sphinxhyphen{}allocation constraint governs structure and function of microbial communities in metabolic modeling. \sphinxstyleemphasis{Metabolic Engineering}, 70:12\textendash{}22, 2022.
\end{sphinxthebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}